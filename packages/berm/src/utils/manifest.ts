import { existsSync } from "node:fs";
import { readFile, rm, writeFile } from "node:fs/promises";
import { join } from "pathe";
import { stringify, parse } from "yaml";
import type { FileDiff, PushManifest, DiffResult } from "../modules/schemas";
import { pushManifestSchema } from "../modules/schemas";
import type { UntrackedFilesByFolder } from "./untracked";

/** マニフェストファイル名 */
export const MANIFEST_FILENAME = ".devenv-push-manifest.yaml";

/** マニフェストファイルのヘッダーコメント */
const MANIFEST_HEADER = `# ================================================================================
# berm push manifest
# ================================================================================
#
# This file was generated by \`berm push --prepare\`
#
# USAGE (for AI agents and humans):
#   1. Review and edit this file:
#      - Set \`selected: true\` for files you want to include in the PR
#      - Set \`selected: false\` for files you want to exclude
#      - Edit \`pr.title\` and \`pr.body\` as needed
#   2. Run \`berm push --execute\` to create the PR
#
# GITHUB TOKEN:
#   Set the GITHUB_TOKEN or GH_TOKEN environment variable, or
#   add the token directly in the github.token field below.
#
# ================================================================================

`;

export interface GenerateManifestOptions {
  /** ターゲットディレクトリ */
  targetDir: string;
  /** 差分結果 */
  diff: DiffResult;
  /** プッシュ可能なファイル */
  pushableFiles: FileDiff[];
  /** 未追跡ファイル（ホワイトリスト外） */
  untrackedByFolder?: UntrackedFilesByFolder[];
  /** デフォルトのPRタイトル */
  defaultTitle?: string;
  /** modules.jsonc の変更パス（ローカルモジュール追加がある場合） */
  modulesFileChange?: string;
}

/**
 * 差分の行数を計算（localContent と templateContent から）
 */
function countDiffLines(
  localContent?: string,
  templateContent?: string,
  type?: string,
): { added: number; removed: number } {
  // 新規追加ファイル
  if (type === "added" && localContent) {
    const lines = localContent.split("\n").length;
    return { added: lines, removed: 0 };
  }

  // 削除ファイル
  if (type === "deleted" && templateContent) {
    const lines = templateContent.split("\n").length;
    return { added: 0, removed: lines };
  }

  // 変更ファイル
  if (type === "modified" && localContent && templateContent) {
    const localLines = localContent.split("\n");
    const templateLines = templateContent.split("\n");

    // 簡易的な差分計算（行数の差）
    // より正確には diff ライブラリを使うべきだが、参考情報なのでこれで十分
    const added = Math.max(0, localLines.length - templateLines.length);
    const removed = Math.max(0, templateLines.length - localLines.length);

    // 両方が0の場合は、内容は変わっているが行数は同じ
    // その場合は変更行数として1を返す
    if (added === 0 && removed === 0 && localContent !== templateContent) {
      return { added: 1, removed: 1 };
    }

    return { added, removed };
  }

  return { added: 0, removed: 0 };
}

/**
 * マニフェストファイルを生成
 */
export function generateManifest(options: GenerateManifestOptions): PushManifest {
  const { diff, pushableFiles, untrackedByFolder, defaultTitle, modulesFileChange } = options;

  const manifest: PushManifest = {
    version: 1,
    generated_at: new Date().toISOString(),
    github: {
      token: undefined, // 環境変数から取得することを推奨
    },
    pr: {
      title: defaultTitle || "feat: update template configuration",
      body: undefined,
    },
    files: [
      ...pushableFiles.map((file) => {
        const { added, removed } = countDiffLines(
          file.localContent,
          file.templateContent,
          file.type,
        );
        return {
          path: file.path,
          type: file.type as "added" | "modified" | "deleted" | "unchanged",
          selected: true, // デフォルトで全選択
          lines_added: added > 0 ? added : undefined,
          lines_removed: removed > 0 ? removed : undefined,
        };
      }),
      // modules.jsonc の変更がある場合はマニフェストに含める
      ...(modulesFileChange
        ? [
            {
              path: modulesFileChange,
              type: "modified" as const,
              selected: true,
            },
          ]
        : []),
    ],
    untracked_files: untrackedByFolder?.flatMap((folder) =>
      folder.files.map((file) => ({
        path: file.path,
        module_id: file.moduleId,
        selected: false, // 未追跡はデフォルト非選択
      })),
    ),
    summary: {
      added: diff.summary.added,
      modified: diff.summary.modified,
      deleted: diff.summary.deleted,
    },
  };

  return manifest;
}

/**
 * マニフェストをYAML文字列に変換
 */
export function serializeManifest(manifest: PushManifest): string {
  const yamlContent = stringify(manifest, {
    indent: 2,
    lineWidth: 120,
  });

  return MANIFEST_HEADER + yamlContent;
}

/**
 * マニフェストファイルを保存
 */
export async function saveManifest(targetDir: string, manifest: PushManifest): Promise<string> {
  const manifestPath = join(targetDir, MANIFEST_FILENAME);
  const content = serializeManifest(manifest);
  await writeFile(manifestPath, content, "utf-8");
  return manifestPath;
}

/**
 * マニフェストファイルを読み込み
 */
export async function loadManifest(targetDir: string): Promise<PushManifest> {
  const manifestPath = join(targetDir, MANIFEST_FILENAME);

  if (!existsSync(manifestPath)) {
    throw new Error(
      `Manifest file not found: ${manifestPath}\n` +
        `Run 'berm push --prepare' first to generate the manifest.`,
    );
  }

  const content = await readFile(manifestPath, "utf-8");
  const parsed = parse(content);

  const result = pushManifestSchema.safeParse(parsed);
  if (!result.success) {
    throw new Error(`Invalid manifest file format: ${result.error.message}`);
  }

  return result.data;
}

/**
 * マニフェストファイルを削除する。
 *
 * 背景: --execute でPR作成が成功した後、マニフェストはもう不要なので自動的にクリーンアップする。
 * ファイルが存在しない場合は何もしない。
 */
export async function deleteManifest(targetDir: string): Promise<void> {
  const manifestPath = join(targetDir, MANIFEST_FILENAME);
  if (existsSync(manifestPath)) {
    await rm(manifestPath);
  }
}

/**
 * マニフェストファイルが存在するか確認
 */
export function manifestExists(targetDir: string): boolean {
  return existsSync(join(targetDir, MANIFEST_FILENAME));
}

/**
 * 選択されたファイルのパスを取得
 */
export function getSelectedFilePaths(manifest: PushManifest): string[] {
  return manifest.files.filter((f) => f.selected).map((f) => f.path);
}

/**
 * 選択された未追跡ファイルを取得（moduleId別）
 */
export function getSelectedUntrackedFiles(manifest: PushManifest): Map<string, string[]> {
  const result = new Map<string, string[]>();

  if (!manifest.untracked_files) {
    return result;
  }

  for (const file of manifest.untracked_files) {
    if (file.selected) {
      const existing = result.get(file.module_id) || [];
      existing.push(file.path);
      result.set(file.module_id, existing);
    }
  }

  return result;
}
