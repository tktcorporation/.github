#!/usr/bin/env node
import { Separator, checkbox, confirm, input, password, select } from "@inquirer/prompts";
import { defineCommand, runMain } from "citty";
import { copyFileSync, existsSync, mkdirSync, rmSync, writeFileSync } from "node:fs";
import { readFile, rm, writeFile } from "node:fs/promises";
import { dirname, extname, join, resolve } from "pathe";
import { parse, stringify } from "yaml";
import { z } from "zod";
import { downloadTemplate } from "giget";
import { applyEdits, modify, parse as parse$1 } from "jsonc-parser";
import { createPatch, diffWords } from "diff";
import ignore from "ignore";
import { globSync } from "tinyglobby";
import { createSpinner } from "nanospinner";
import pc, { default as pc$1 } from "picocolors";
import { P, match } from "ts-pattern";
import * as readline from "node:readline";
import { highlight, supportsLanguage } from "cli-highlight";
import { Octokit } from "@octokit/rest";

//#region package.json
var version$1 = "0.11.2";

//#endregion
//#region src/modules/schemas.ts
/** 非負整数（行数カウント用） */
const nonNegativeIntSchema = z.number().int().nonnegative().brand();
/** ファイルパス */
const filePathSchema = z.string().min(1).brand();
const overwriteStrategySchema = z.enum([
	"overwrite",
	"skip",
	"prompt"
]);
const fileActionSchema = z.enum([
	"copied",
	"created",
	"overwritten",
	"skipped",
	"skipped_ignored"
]);
const fileOperationResultSchema = z.object({
	action: fileActionSchema,
	path: z.string()
});
const moduleSchema = z.object({
	id: z.string(),
	name: z.string(),
	description: z.string(),
	setupDescription: z.string().optional(),
	patterns: z.array(z.string())
});
const configSchema = z.object({
	version: z.string(),
	installedAt: z.string().datetime({ offset: true }),
	modules: z.array(z.string()),
	source: z.object({
		owner: z.string(),
		repo: z.string(),
		ref: z.string().optional()
	}),
	excludePatterns: z.array(z.string()).optional()
});
const answersSchema = z.object({
	modules: z.array(z.string()).min(1, "少なくとも1つのモジュールを選択してください"),
	overwriteStrategy: overwriteStrategySchema
});
const diffTypeSchema = z.enum([
	"added",
	"modified",
	"deleted",
	"unchanged"
]);
const fileDiffSchema = z.object({
	path: z.string(),
	type: diffTypeSchema,
	localContent: z.string().optional(),
	templateContent: z.string().optional()
});
const diffResultSchema = z.object({
	files: z.array(fileDiffSchema),
	summary: z.object({
		added: z.number(),
		modified: z.number(),
		deleted: z.number(),
		unchanged: z.number()
	})
});
const prResultSchema = z.object({
	url: z.string(),
	number: z.number(),
	branch: z.string()
});
/** マニフェスト内のファイルエントリ */
const manifestFileSchema = z.object({
	path: z.string(),
	type: diffTypeSchema,
	selected: z.boolean(),
	lines_added: z.number().optional(),
	lines_removed: z.number().optional()
});
/** マニフェスト内の未追跡ファイルエントリ */
const manifestUntrackedFileSchema = z.object({
	path: z.string(),
	module_id: z.string(),
	selected: z.boolean()
});
/** GitHub設定 */
const manifestGitHubSchema = z.object({ token: z.string().optional() });
/** PR設定 */
const manifestPrSchema = z.object({
	title: z.string(),
	body: z.string().optional()
});
/** サマリー（読み取り専用） */
const manifestSummarySchema = z.object({
	added: z.number(),
	modified: z.number(),
	deleted: z.number()
});
/** Push マニフェスト全体 */
const pushManifestSchema = z.object({
	version: z.literal(1),
	generated_at: z.string().datetime({ offset: true }),
	github: manifestGitHubSchema,
	pr: manifestPrSchema,
	files: z.array(manifestFileSchema),
	untracked_files: z.array(manifestUntrackedFileSchema).optional(),
	summary: manifestSummarySchema
});

//#endregion
//#region src/utils/manifest.ts
/** マニフェストファイル名 */
const MANIFEST_FILENAME = ".devenv-push-manifest.yaml";
/** マニフェストファイルのヘッダーコメント */
const MANIFEST_HEADER = `# ================================================================================
# berm push manifest
# ================================================================================
#
# This file was generated by \`berm push --prepare\`
#
# USAGE (for AI agents and humans):
#   1. Review and edit this file:
#      - Set \`selected: true\` for files you want to include in the PR
#      - Set \`selected: false\` for files you want to exclude
#      - Edit \`pr.title\` and \`pr.body\` as needed
#   2. Run \`berm push --execute\` to create the PR
#
# GITHUB TOKEN:
#   Set the GITHUB_TOKEN or GH_TOKEN environment variable, or
#   add the token directly in the github.token field below.
#
# ================================================================================

`;
/**
* 差分の行数を計算（localContent と templateContent から）
*/
function countDiffLines(localContent, templateContent, type) {
	if (type === "added" && localContent) return {
		added: localContent.split("\n").length,
		removed: 0
	};
	if (type === "deleted" && templateContent) return {
		added: 0,
		removed: templateContent.split("\n").length
	};
	if (type === "modified" && localContent && templateContent) {
		const localLines = localContent.split("\n");
		const templateLines = templateContent.split("\n");
		const added = Math.max(0, localLines.length - templateLines.length);
		const removed = Math.max(0, templateLines.length - localLines.length);
		if (added === 0 && removed === 0 && localContent !== templateContent) return {
			added: 1,
			removed: 1
		};
		return {
			added,
			removed
		};
	}
	return {
		added: 0,
		removed: 0
	};
}
/**
* マニフェストファイルを生成
*/
function generateManifest(options) {
	const { diff, pushableFiles, untrackedByFolder, defaultTitle, modulesFileChange } = options;
	return {
		version: 1,
		generated_at: (/* @__PURE__ */ new Date()).toISOString(),
		github: { token: void 0 },
		pr: {
			title: defaultTitle || "feat: update template configuration",
			body: void 0
		},
		files: [...pushableFiles.map((file) => {
			const { added, removed } = countDiffLines(file.localContent, file.templateContent, file.type);
			return {
				path: file.path,
				type: file.type,
				selected: true,
				lines_added: added > 0 ? added : void 0,
				lines_removed: removed > 0 ? removed : void 0
			};
		}), ...modulesFileChange ? [{
			path: modulesFileChange,
			type: "modified",
			selected: true
		}] : []],
		untracked_files: untrackedByFolder?.flatMap((folder) => folder.files.map((file) => ({
			path: file.path,
			module_id: file.moduleId,
			selected: false
		}))),
		summary: {
			added: diff.summary.added,
			modified: diff.summary.modified,
			deleted: diff.summary.deleted
		}
	};
}
/**
* マニフェストをYAML文字列に変換
*/
function serializeManifest(manifest) {
	return MANIFEST_HEADER + stringify(manifest, {
		indent: 2,
		lineWidth: 120
	});
}
/**
* マニフェストファイルを保存
*/
async function saveManifest(targetDir, manifest) {
	const manifestPath = join(targetDir, MANIFEST_FILENAME);
	await writeFile(manifestPath, serializeManifest(manifest), "utf-8");
	return manifestPath;
}
/**
* マニフェストファイルを読み込み
*/
async function loadManifest(targetDir) {
	const manifestPath = join(targetDir, MANIFEST_FILENAME);
	if (!existsSync(manifestPath)) throw new Error(`Manifest file not found: ${manifestPath}\nRun 'berm push --prepare' first to generate the manifest.`);
	const parsed = parse(await readFile(manifestPath, "utf-8"));
	const result = pushManifestSchema.safeParse(parsed);
	if (!result.success) throw new Error(`Invalid manifest file format: ${result.error.message}`);
	return result.data;
}
/**
* マニフェストファイルを削除する。
*
* 背景: --execute でPR作成が成功した後、マニフェストはもう不要なので自動的にクリーンアップする。
* ファイルが存在しない場合は何もしない。
*/
async function deleteManifest(targetDir) {
	const manifestPath = join(targetDir, MANIFEST_FILENAME);
	if (existsSync(manifestPath)) await rm(manifestPath);
}
/**
* 選択されたファイルのパスを取得
*/
function getSelectedFilePaths(manifest) {
	return manifest.files.filter((f) => f.selected).map((f) => f.path);
}
/**
* 選択された未追跡ファイルを取得（moduleId別）
*/
function getSelectedUntrackedFiles(manifest) {
	const result = /* @__PURE__ */ new Map();
	if (!manifest.untracked_files) return result;
	for (const file of manifest.untracked_files) if (file.selected) {
		const existing = result.get(file.module_id) || [];
		existing.push(file.path);
		result.set(file.module_id, existing);
	}
	return result;
}

//#endregion
//#region src/docs/ai-guide.ts
/**
* AI Agent Guide
*
* This file serves as the single source of truth for AI-facing documentation.
* It is used both for:
*   - `berm ai-docs` command output
*   - README.md "For AI Agents" section generation
*/
/**
* Generate the complete AI agent guide as markdown
*/
function generateAiGuide() {
	return getDocSections().map((s) => `## ${s.title}\n\n${s.content}`).join("\n\n");
}
/**
* Generate the AI agent guide with header for CLI output
*/
function generateAiGuideWithHeader() {
	return `# berm v${version$1} - AI Agent Guide

This guide explains how AI coding agents (Claude Code, Cursor, etc.) can use this tool effectively.

` + generateAiGuide();
}
/**
* Get individual documentation sections
* Used by both CLI output and README generation
*/
function getDocSections() {
	return [
		{
			title: "Quick Reference",
			content: `\`\`\`bash
# Non-interactive init for AI agents
npx @tktco/berm init --yes                           # All modules, overwrite strategy
npx @tktco/berm init --modules .,devcontainer        # Specific modules only
npx @tktco/berm init --modules .github -s skip       # Specific modules with skip strategy
npx @tktco/berm init --yes --overwrite-strategy skip # All modules with skip strategy

# Non-interactive push workflow for AI agents
npx @tktco/berm push --prepare    # Generate manifest
# Edit ${MANIFEST_FILENAME}              # Select files
npx @tktco/berm push --execute    # Create PR

# Add files to tracking (non-interactive)
npx @tktco/berm track ".cloud/rules/*.md"            # Add pattern (auto-detect module)
npx @tktco/berm track ".cloud/config.json" -m .cloud # Specify module explicitly
npx @tktco/berm track --list                         # List tracked modules/patterns

# Show differences and detect untracked files
npx @tktco/berm diff              # Show differences (also reports untracked files)

# Other commands
npx @tktco/berm init [dir]        # Apply template (interactive)
npx @tktco/berm ai-docs           # Show this guide
\`\`\``
		},
		{
			title: "Init Command for AI Agents",
			content: `The \`init\` command supports non-interactive options for AI agents:

### Options

| Option | Alias | Description |
|--------|-------|-------------|
| \`--yes\` | \`-y\` | Select all modules with overwrite strategy |
| \`--modules <ids>\` | \`-m\` | Comma-separated module IDs to apply |
| \`--overwrite-strategy <strategy>\` | \`-s\` | Strategy for existing files: \`overwrite\`, \`skip\`, or \`prompt\` |
| \`--force\` | | Force overwrite (overrides strategy to \`overwrite\`) |

### Examples

\`\`\`bash
# Apply only specific modules (skips module selection prompt)
npx @tktco/berm init --modules .github,.claude

# Apply specific modules and skip existing files
npx @tktco/berm init --modules devcontainer -s skip

# Apply all modules but skip existing files
npx @tktco/berm init --yes --overwrite-strategy skip

# Re-init when .devenv.json exists, replacing only specific modules
npx @tktco/berm init --modules . -s overwrite
\`\`\`

### Behavior

- \`--modules\` or \`--yes\`: Skips the module selection prompt entirely
- \`--overwrite-strategy\`: Sets how to handle existing files (default: \`overwrite\` in non-interactive mode)
- When neither is provided, interactive prompts are shown
- \`.devenv.json\` is always updated regardless of strategy`
		},
		{
			title: "Important: Untracked Files and the Track Command",
			content: `**The \`push\` and \`diff\` commands only operate on files that are in the sync whitelist (tracked patterns).**
If you create new files or directories that don't match any existing pattern, they will appear as **untracked** and will NOT be included in diffs or push operations.

To sync these files to the template, you **must** first add them to tracking:

\`\`\`bash
# 1. Check for untracked files
npx @tktco/berm diff

# 2. Add untracked files to the whitelist
npx @tktco/berm track "<file-or-glob-pattern>"

# 3. Now push will include these files
npx @tktco/berm push --prepare
\`\`\`

**Key points:**
- \`diff\` will report untracked files and suggest using \`track\`
- \`push --prepare\` will list untracked files in the manifest (with \`selected: false\` by default)
- \`track\` is non-interactive and designed for AI agents — no prompts required
- After running \`track\`, re-run \`push --prepare\` to include the newly tracked files`
		},
		{
			title: "Push Workflow for AI Agents",
			content: `When contributing template improvements, use the two-phase workflow:

### Phase 1: Prepare

\`\`\`bash
npx @tktco/berm push --prepare
\`\`\`

This generates \`${MANIFEST_FILENAME}\` containing:
- List of changed files with \`selected: true/false\`
- PR title and body fields
- Summary of changes

### Phase 2: Edit Manifest

Edit the generated \`${MANIFEST_FILENAME}\`:

\`\`\`yaml
pr:
  title: "feat: add new workflow for CI"
  body: |
    ## Summary
    Added new CI workflow for automated testing.

    ## Changes
    - Added .github/workflows/ci.yml

files:
  - path: .github/workflows/ci.yml
    type: added
    selected: true    # Include this file
  - path: .github/labeler.yml
    type: modified
    selected: false   # Exclude this file
\`\`\`

### Phase 3: Execute

\`\`\`bash
# Set GitHub token (required)
export GITHUB_TOKEN="your-token"

# Create the PR
npx @tktco/berm push --execute
\`\`\``
		},
		{
			title: "Manifest File Reference",
			content: `The manifest file (\`${MANIFEST_FILENAME}\`) structure:

| Field | Description |
|-------|-------------|
| \`version\` | Manifest format version (always \`1\`) |
| \`generated_at\` | ISO 8601 timestamp |
| \`github.token\` | GitHub token (prefer env var) |
| \`pr.title\` | PR title (editable) |
| \`pr.body\` | PR description (editable) |
| \`files[].path\` | File path |
| \`files[].type\` | \`added\` / \`modified\` / \`deleted\` |
| \`files[].selected\` | Include in PR (\`true\`/\`false\`) |
| \`untracked_files[]\` | Files outside whitelist (default: \`selected: false\`) |
| \`summary\` | Change statistics |`
		},
		{
			title: "Environment Variables",
			content: `| Variable | Description |
|----------|-------------|
| \`GITHUB_TOKEN\` | GitHub personal access token (required for push) |
| \`GH_TOKEN\` | Alternative to GITHUB_TOKEN |

The token needs \`repo\` scope for creating PRs.`
		},
		{
			title: "Track Command for AI Agents",
			content: `The \`track\` command allows AI agents to add files or patterns to the sync whitelist non-interactively.
This is useful when you create new files or directories that should be part of the template.

### Add patterns to an existing module

\`\`\`bash
# Auto-detects module from path (.claude module)
npx @tktco/berm track ".claude/commands/*.md"

# Explicit module
npx @tktco/berm track ".devcontainer/new-script.sh" --module .devcontainer
\`\`\`

### Create a new module with patterns

When the module doesn't exist yet, it is automatically created:

\`\`\`bash
# Creates ".cloud" module and adds the pattern
npx @tktco/berm track ".cloud/rules/*.md"

# With custom name and description
npx @tktco/berm track ".cloud/rules/*.md" \\
  --module .cloud \\
  --name "Cloud Rules" \\
  --description "Cloud configuration and rule files"
\`\`\`

### List current tracking configuration

\`\`\`bash
npx @tktco/berm track --list
\`\`\`

### Options

| Option | Alias | Description |
|--------|-------|-------------|
| \`--module <id>\` | \`-m\` | Module ID to add patterns to (auto-detected if omitted) |
| \`--name <name>\` | | Module display name (for new modules) |
| \`--description <desc>\` | | Module description (for new modules) |
| \`--dir <path>\` | \`-d\` | Project directory (default: current directory) |
| \`--list\` | \`-l\` | List all tracked modules and patterns |`
		},
		{
			title: "Best Practices for AI Agents",
			content: `1. **Use \`--modules\` and \`--overwrite-strategy\`** for granular non-interactive init (e.g., \`init --modules .github,.claude -s skip\`)
2. **Always use \`--prepare\` then \`--execute\`** for non-interactive push operation
3. **Review the diff first** with \`npx @tktco/berm diff\` — this also reports untracked files
4. **Check for untracked files** — if \`diff\` or \`push --prepare\` reports untracked files, use \`track\` to add them before pushing
5. **Use \`track\` command** to add new files to the sync whitelist (non-interactive, no prompts)
6. **Set meaningful PR titles** that follow conventional commits (e.g., \`feat:\`, \`fix:\`, \`docs:\`)
7. **Deselect unrelated changes** by setting \`selected: false\`
8. **Use environment variables** for tokens instead of hardcoding in manifest`
		},
		{
			title: "Track + Push: Adding New Files to Template",
			content: `When you create new files that should be part of the template, use \`track\` then \`push\`.
The \`push\` command **automatically detects** changes made by \`track\` to the local \`modules.jsonc\`
and includes them in the PR.

### Workflow

\`\`\`bash
# 1. Create files locally
mkdir -p .cloud/rules
echo "naming conventions..." > .cloud/rules/naming.md

# 2. Add to tracking (updates local .devenv/modules.jsonc)
npx @tktco/berm track ".cloud/rules/*.md"

# 3. Push detects local module additions automatically
npx @tktco/berm push --prepare
\`\`\`

### What happens internally

1. \`track\` adds patterns to **local** \`.devenv/modules.jsonc\` (creates new modules if needed)
2. \`push --prepare\` downloads the template and compares its \`modules.jsonc\` with local
3. New modules and patterns are detected and merged into the detection scope
4. The manifest includes:
   - New files (\`.cloud/rules/naming.md\`) as \`type: added\` with \`selected: true\`
   - \`.devenv/modules.jsonc\` as \`type: modified\` with \`selected: true\`
5. \`push --execute\` creates a PR that adds both the files AND the updated module definitions

### Key behavior

- **No need to manually edit modules.jsonc** — \`track\` handles it
- **push detects local changes** — no extra flags needed; just run \`push --prepare\` after \`track\`
- **New modules are auto-created** — if \`.cloud\` doesn't exist in the template, it's added
- **Existing module patterns can also be extended** — \`track\` works for both new and existing modules`
		}
	];
}

//#endregion
//#region src/commands/ai-docs.ts
const aiDocsCommand = defineCommand({
	meta: {
		name: "ai-docs",
		description: "Show documentation for AI coding agents"
	},
	args: {},
	run() {
		console.log(generateAiGuideWithHeader());
	}
});

//#endregion
//#region src/modules/loader.ts
const MODULES_FILE = ".devenv/modules.jsonc";
/**
* modules.jsonc のスキーマ
*/
const modulesFileSchema = z.object({
	$schema: z.string().optional(),
	modules: z.array(moduleSchema)
});
/**
* modules.jsonc ファイルを読み込み
*/
async function loadModulesFile(baseDir) {
	const filePath = join(baseDir, MODULES_FILE);
	if (!existsSync(filePath)) throw new Error(`${MODULES_FILE} が見つかりません: ${filePath}`);
	const content = await readFile(filePath, "utf-8");
	const parsed = parse$1(content);
	return {
		modules: modulesFileSchema.parse(parsed).modules,
		rawContent: content
	};
}
/**
* modules.jsonc にパターンを追加（コメントを保持）
* @returns 更新後の JSONC 文字列
*/
function addPatternToModulesFile(rawContent, moduleId, patterns) {
	const parsed = parse$1(rawContent);
	const moduleIndex = parsed.modules.findIndex((m) => m.id === moduleId);
	if (moduleIndex === -1) throw new Error(`モジュール ${moduleId} が見つかりません`);
	const existingPatterns = parsed.modules[moduleIndex].patterns;
	const newPatterns = patterns.filter((p) => !existingPatterns.includes(p));
	if (newPatterns.length === 0) return rawContent;
	const updatedPatterns = [...existingPatterns, ...newPatterns];
	return applyEdits(rawContent, modify(rawContent, [
		"modules",
		moduleIndex,
		"patterns"
	], updatedPatterns, { formattingOptions: {
		tabSize: 2,
		insertSpaces: true
	} }));
}
/**
* modules.jsonc にパターンを追加（モジュールが存在しない場合は作成）
* @returns 更新後の JSONC 文字列
*/
function addPatternToModulesFileWithCreate(rawContent, moduleId, patterns, moduleOptions) {
	const parsed = parse$1(rawContent);
	if (parsed.modules.findIndex((m) => m.id === moduleId) !== -1) return addPatternToModulesFile(rawContent, moduleId, patterns);
	const newModule = {
		id: moduleId,
		name: moduleOptions?.name || (moduleId === "." ? "Root" : moduleId.replace(/^\./, "").replace(/[-_]/g, " ").replace(/\b\w/g, (c) => c.toUpperCase())),
		description: moduleOptions?.description || `Files in ${moduleId === "." ? "root" : moduleId} directory`,
		patterns
	};
	return applyEdits(rawContent, modify(rawContent, ["modules"], [...parsed.modules, newModule], { formattingOptions: {
		tabSize: 2,
		insertSpaces: true
	} }));
}
/**
* modules.jsonc を保存
*/
async function saveModulesFile(baseDir, content) {
	await writeFile(join(baseDir, MODULES_FILE), content);
}
/**
* モジュールファイルのパスを取得
*/
function getModulesFilePath(baseDir) {
	return join(baseDir, MODULES_FILE);
}
/**
* modules.jsonc が存在するか確認
*/
function modulesFileExists(baseDir) {
	return existsSync(join(baseDir, MODULES_FILE));
}

//#endregion
//#region src/modules/index.ts
/**
* デフォルトモジュール（modules.jsonc がない場合のフォールバック）
* モジュール ID = ディレクトリパス（ルートは "."）
*/
const defaultModules = [
	{
		id: ".",
		name: "ルート設定",
		description: "MCP、mise などのルート設定ファイル",
		setupDescription: "プロジェクトルートの設定ファイルが適用されます",
		patterns: [".mcp.json", ".mise.toml"]
	},
	{
		id: ".devcontainer",
		name: "DevContainer",
		description: "VS Code DevContainer、Docker-in-Docker",
		setupDescription: "VS Code で DevContainer を開くと自動でセットアップされます",
		patterns: [
			".devcontainer/devcontainer.json",
			".devcontainer/.gitignore",
			".devcontainer/setup-*.sh",
			".devcontainer/test-*.sh",
			".devcontainer/.env.devcontainer.example"
		]
	},
	{
		id: ".github",
		name: "GitHub",
		description: "GitHub Actions、labeler ワークフロー",
		setupDescription: "PR 作成時に自動でラベル付け、Issue リンクが行われます",
		patterns: [
			".github/workflows/issue-link.yml",
			".github/workflows/label.yml",
			".github/labeler.yml"
		]
	},
	{
		id: ".claude",
		name: "Claude",
		description: "Claude Code のプロジェクト共通設定",
		setupDescription: "Claude Code のプロジェクト設定が適用されます",
		patterns: [".claude/settings.json"]
	}
];
/**
* モジュールリストから ID でモジュールを取得
*/
function getModuleById(id, moduleList = defaultModules) {
	return moduleList.find((m) => m.id === id);
}

//#endregion
//#region src/utils/gitignore.ts
/**
* 複数ディレクトリの .gitignore をマージして読み込み
* ローカルとテンプレートの両方の .gitignore を考慮することで、
* クレデンシャル等の機密情報の誤流出を防止する
*/
async function loadMergedGitignore(dirs) {
	const ig = ignore();
	for (const dir of dirs) {
		const gitignorePath = join(dir, ".gitignore");
		if (existsSync(gitignorePath)) {
			const content = await readFile(gitignorePath, "utf-8");
			ig.add(content);
		}
	}
	return ig;
}
/**
* gitignore ルールでファイルをフィルタリング
* gitignore に該当しないファイルのみを返す
*/
function filterByGitignore(files, ig) {
	return ig.filter(files);
}
function separateByGitignore(files, ig) {
	const tracked = [];
	const ignored = [];
	for (const file of files) if (ig.ignores(file)) ignored.push(file);
	else tracked.push(file);
	return {
		tracked,
		ignored
	};
}

//#endregion
//#region src/utils/patterns.ts
/**
* パターンにマッチするファイル一覧を取得
*/
function resolvePatterns(baseDir, patterns) {
	return globSync(patterns, {
		cwd: baseDir,
		dot: true,
		onlyFiles: true
	}).sort();
}
/**
* ファイルがパターンにマッチするか判定
*/
function matchesPatterns(filePath, patterns) {
	for (const pattern of patterns) {
		if (filePath === pattern) return true;
		if (isGlobPattern(pattern)) {
			if (globSync([pattern], {
				cwd: ".",
				expandDirectories: false
			}).includes(filePath)) return true;
		}
	}
	return false;
}
/**
* パターンが glob パターンかどうかを判定
*/
function isGlobPattern(pattern) {
	return /[*?[\]{}!]/.test(pattern);
}
/**
* 設定からモジュールの有効パターンを取得
*/
function getEffectivePatterns(_moduleId, modulePatterns, config) {
	let patterns = [...modulePatterns];
	if (config?.excludePatterns) {
		const excludePatterns = config.excludePatterns;
		patterns = patterns.filter((p) => !matchesPatterns(p, excludePatterns));
	}
	return patterns;
}

//#endregion
//#region src/utils/ui.ts
/**
* UI Utilities - モダンな CLI 出力ヘルパー
*
* create-t3-app, create-next-app, degit などを参考にした
* 一貫性のある美しい出力を提供
*/
const S = {
	success: pc$1.green("✓"),
	error: pc$1.red("✗"),
	warning: pc$1.yellow("⚠"),
	info: pc$1.blue("●"),
	step: pc$1.cyan("◆"),
	arrow: pc$1.dim("→"),
	bar: pc$1.dim("│"),
	corner: pc$1.dim("└"),
	tee: pc$1.dim("├")
};
/**
* シンプルなヘッダーを表示
*/
function showHeader(title, version$2) {
	console.log();
	const versionStr = version$2 ? pc$1.dim(` v${version$2}`) : "";
	console.log(`${pc$1.bold(pc$1.cyan(title))}${versionStr}`);
	console.log(pc$1.dim("─".repeat(40)));
}
/**
* スピナー付きのタスクを実行
*/
function spinner(text) {
	const s = createSpinner(text, { color: "cyan" });
	return {
		start: () => s.start(),
		stop: () => s.stop(),
		success: (msg) => s.success({ text: msg || text }),
		error: (msg) => s.error({ text: msg || text })
	};
}
/**
* スピナー付きで非同期タスクを実行
*/
async function withSpinner(text, task) {
	const s = spinner(text);
	s.start();
	try {
		const result = await task();
		s.success();
		return result;
	} catch (error) {
		s.error();
		throw error;
	}
}
/**
* ステップを表示 (例: [1/3] テンプレートを取得中...)
*/
function step(ctx, message) {
	const prefix = pc$1.dim(`[${ctx.current}/${ctx.total}]`);
	console.log(`${prefix} ${S.step} ${message}`);
}
const log = {
	success: (message) => {
		console.log(`${S.success} ${message}`);
	},
	error: (message) => {
		console.log(`${S.error} ${pc$1.red(message)}`);
	},
	warn: (message) => {
		console.log(`${S.warning} ${pc$1.yellow(message)}`);
	},
	info: (message) => {
		console.log(`${S.info} ${message}`);
	},
	dim: (message) => {
		console.log(pc$1.dim(`  ${message}`));
	},
	newline: () => {
		console.log();
	}
};
const actionIcons = {
	copied: pc$1.green("+"),
	created: pc$1.green("+"),
	overwritten: pc$1.yellow("~"),
	skipped: pc$1.dim("-"),
	skipped_ignored: pc$1.yellow("⚠")
};
const actionLabels = {
	copied: pc$1.green("added"),
	created: pc$1.green("added"),
	overwritten: pc$1.yellow("updated"),
	skipped: pc$1.dim("skipped"),
	skipped_ignored: pc$1.yellow("skipped (gitignore)")
};
/**
* ファイル操作結果を1行で表示
*/
function logFileResult(result) {
	const icon = actionIcons[result.action];
	const label = actionLabels[result.action];
	const path = result.action === "skipped" || result.action === "skipped_ignored" ? pc$1.dim(result.path) : result.path;
	console.log(`  ${icon} ${path} ${pc$1.dim(`(${label})`)}`);
}
/**
* 操作結果からサマリーを計算
*/
function calculateSummary(results) {
	return results.reduce((acc, r) => {
		if (r.action === "copied" || r.action === "created") acc.added++;
		else if (r.action === "overwritten") acc.updated++;
		else if (r.action === "skipped_ignored") acc.skippedIgnored++;
		else acc.skipped++;
		return acc;
	}, {
		added: 0,
		updated: 0,
		skipped: 0,
		skippedIgnored: 0
	});
}
/**
* 完了サマリーを表示
*/
function showSummary(summary) {
	const parts = [];
	if (summary.added > 0) parts.push(pc$1.green(`${summary.added} added`));
	if (summary.updated > 0) parts.push(pc$1.yellow(`${summary.updated} updated`));
	if (summary.skipped > 0) parts.push(pc$1.dim(`${summary.skipped} skipped`));
	if (summary.skippedIgnored > 0) parts.push(pc$1.yellow(`${summary.skippedIgnored} skipped (gitignore)`));
	if (parts.length > 0) {
		console.log();
		console.log(pc$1.dim("─".repeat(40)));
		console.log(`${S.success} ${pc$1.bold("Done!")} ${parts.join(", ")}`);
	}
}
/**
* 次のステップを表示
*/
function showNextSteps(steps) {
	if (steps.length === 0) return;
	console.log();
	console.log(pc$1.bold("Next steps:"));
	console.log();
	for (const step$1 of steps) if (step$1.command) {
		console.log(`  ${S.arrow} ${pc$1.cyan(step$1.command)}`);
		console.log(`    ${pc$1.dim(step$1.description)}`);
	} else console.log(`  ${S.arrow} ${step$1.description}`);
	console.log();
}
/**
* ボックスで囲んだメッセージを表示
*/
function box(message, type = "info") {
	const color = {
		success: pc$1.green,
		info: pc$1.cyan,
		warning: pc$1.yellow
	}[type];
	const width = message.length + 4;
	const top = color("╭" + "─".repeat(width - 2) + "╮");
	const bottom = color("╰" + "─".repeat(width - 2) + "╯");
	const middle = color("│") + " " + message + " " + color("│");
	console.log();
	console.log(top);
	console.log(middle);
	console.log(bottom);
	console.log();
}
/**
* diff ヘッダーを表示
*/
function diffHeader(title) {
	console.log();
	console.log(pc$1.bold(title));
	console.log(pc$1.dim("─".repeat(50)));
}

//#endregion
//#region src/utils/diff.ts
/**
* ローカルとテンプレート間の差分を検出
*/
async function detectDiff(options) {
	const { targetDir, templateDir, moduleIds, config, moduleList = defaultModules } = options;
	const files = [];
	let added = 0;
	let modified = 0;
	let deleted = 0;
	let unchanged = 0;
	const gitignore = await loadMergedGitignore([targetDir, templateDir]);
	for (const moduleId of moduleIds) {
		const mod = getModuleById(moduleId, moduleList);
		if (!mod) {
			log.warn(`Module "${pc$1.cyan(moduleId)}" not found`);
			continue;
		}
		const patterns = getEffectivePatterns(moduleId, mod.patterns, config);
		const templateFiles = filterByGitignore(resolvePatterns(templateDir, patterns), gitignore);
		const localFiles = filterByGitignore(resolvePatterns(targetDir, patterns), gitignore);
		const allFiles = new Set([...templateFiles, ...localFiles]);
		for (const filePath of allFiles) {
			const localPath = join(targetDir, filePath);
			const templatePath = join(templateDir, filePath);
			const localExists = existsSync(localPath);
			const templateExists = existsSync(templatePath);
			let type;
			let localContent;
			let templateContent;
			if (localExists) localContent = await readFile(localPath, "utf-8");
			if (templateExists) templateContent = await readFile(templatePath, "utf-8");
			if (localExists && templateExists) if (localContent === templateContent) {
				type = "unchanged";
				unchanged++;
			} else {
				type = "modified";
				modified++;
			}
			else if (localExists && !templateExists) {
				type = "added";
				added++;
			} else {
				type = "deleted";
				deleted++;
			}
			files.push({
				path: filePath,
				type,
				localContent,
				templateContent
			});
		}
	}
	return {
		files: files.sort((a, b) => a.path.localeCompare(b.path)),
		summary: {
			added,
			modified,
			deleted,
			unchanged
		}
	};
}
/**
* 差分をフォーマットして表示用文字列を生成
*/
function formatDiff(diff, verbose = false) {
	const lines = [];
	const summaryParts = [];
	if (diff.summary.added > 0) summaryParts.push(pc$1.green(`+${diff.summary.added} added`));
	if (diff.summary.modified > 0) summaryParts.push(pc$1.yellow(`~${diff.summary.modified} modified`));
	if (diff.summary.deleted > 0) summaryParts.push(pc$1.red(`-${diff.summary.deleted} deleted`));
	if (diff.summary.unchanged > 0) summaryParts.push(pc$1.dim(`${diff.summary.unchanged} unchanged`));
	if (summaryParts.length > 0) {
		lines.push(`  ${summaryParts.join(pc$1.dim(" │ "))}`);
		lines.push("");
	}
	const changedFiles = diff.files.filter((f) => f.type !== "unchanged");
	if (changedFiles.length > 0) for (const file of changedFiles) {
		const { icon, color } = getStatusStyle(file.type);
		lines.push(`  ${icon} ${color(file.path)}`);
		if (verbose && file.type === "modified") lines.push(pc$1.dim("    └─ Content differs from template"));
	}
	else lines.push(pc$1.dim("  No changes detected"));
	return lines.join("\n");
}
function getStatusStyle(type) {
	switch (type) {
		case "added": return {
			icon: pc$1.green("+"),
			color: pc$1.green
		};
		case "modified": return {
			icon: pc$1.yellow("~"),
			color: pc$1.yellow
		};
		case "deleted": return {
			icon: pc$1.red("-"),
			color: pc$1.red
		};
		case "unchanged": return {
			icon: pc$1.dim(" "),
			color: pc$1.dim
		};
	}
}
/**
* push 対象のファイルのみをフィルタリング
* (ローカルで追加・変更されたファイル)
*/
function getPushableFiles(diff) {
	return diff.files.filter((f) => f.type === "added" || f.type === "modified");
}
/**
* 差分があるかどうかを判定
*/
function hasDiff(diff) {
	return diff.summary.added > 0 || diff.summary.modified > 0 || diff.summary.deleted > 0;
}
/**
* FileDiff から unified diff 形式の文字列を生成
*/
function generateUnifiedDiff(fileDiff) {
	const { path, type, localContent, templateContent } = fileDiff;
	switch (type) {
		case "added": return createPatch(path, "", localContent || "", "template", "local");
		case "modified": return createPatch(path, templateContent || "", localContent || "", "template", "local");
		default: return "";
	}
}

//#endregion
//#region src/utils/untracked.ts
/**
* ファイルパスからモジュール ID を取得
* モジュール ID = ディレクトリパス（ルートは "."）
*
* 例:
*   ".devcontainer/file.json" → ".devcontainer"
*   ".mcp.json" → "."
*   ".github/workflows/ci.yml" → ".github"
*/
function getModuleIdFromPath(filePath) {
	const parts = filePath.split("/");
	if (parts.length === 1) return ".";
	return parts[0];
}
/**
* 後方互換性のため: フォルダ名を表示用に取得
* "." は "root" として表示
*/
function getDisplayFolder(moduleId) {
	return moduleId === "." ? "root" : moduleId;
}
/**
* モジュールのベースディレクトリを取得
* モジュール ID がそのままディレクトリパスになる
*/
function getModuleBaseDir(moduleId) {
	if (moduleId === ".") return null;
	return moduleId;
}
/**
* ディレクトリ内の全ファイルを取得
*/
function getAllFilesInDirs(baseDir, dirs) {
	if (dirs.length === 0) return [];
	return globSync(dirs.map((d) => `${d}/**/*`), {
		cwd: baseDir,
		dot: true,
		onlyFiles: true
	}).sort();
}
/**
* ルート直下の隠しファイルを取得
*/
function getRootDotFiles(baseDir) {
	return globSync([".*"], {
		cwd: baseDir,
		dot: true,
		onlyFiles: true
	}).sort();
}
/**
* 複数ディレクトリの .gitignore をマージして読み込み
* サブディレクトリの .gitignore も含める
*/
async function loadAllGitignores(baseDir, dirs) {
	const ig = ignore();
	const rootGitignore = join(baseDir, ".gitignore");
	if (existsSync(rootGitignore)) {
		const content = await readFile(rootGitignore, "utf-8");
		ig.add(content);
	}
	for (const dir of dirs) {
		const gitignorePath = join(baseDir, dir, ".gitignore");
		if (existsSync(gitignorePath)) {
			const prefixedContent = (await readFile(gitignorePath, "utf-8")).split("\n").map((line) => {
				const trimmed = line.trim();
				if (!trimmed || trimmed.startsWith("#")) return line;
				if (trimmed.startsWith("!")) return `!${dir}/${trimmed.slice(1)}`;
				return `${dir}/${trimmed}`;
			}).join("\n");
			ig.add(prefixedContent);
		}
	}
	return ig;
}
/**
* ホワイトリスト外のファイルをフォルダごとに検出
*/
async function detectUntrackedFiles(options) {
	const { targetDir, moduleIds, config, moduleList = defaultModules } = options;
	const installedModuleIds = new Set(moduleIds);
	const allBaseDirs = [];
	const allTrackedFiles = /* @__PURE__ */ new Set();
	let hasRootModule = false;
	for (const moduleId of moduleIds) {
		const mod = getModuleById(moduleId, moduleList);
		if (!mod) continue;
		const baseDir = getModuleBaseDir(moduleId);
		if (baseDir) allBaseDirs.push(baseDir);
		else hasRootModule = true;
		const trackedFiles = resolvePatterns(targetDir, getEffectivePatterns(moduleId, mod.patterns, config));
		for (const file of trackedFiles) allTrackedFiles.add(file);
	}
	const gitignore = await loadAllGitignores(targetDir, allBaseDirs);
	const allDirFiles = getAllFilesInDirs(targetDir, allBaseDirs);
	const filteredDirFiles = gitignore.filter(allDirFiles);
	const filteredRootFiles = hasRootModule ? gitignore.filter(getRootDotFiles(targetDir)) : [];
	const allFiles = new Set([...filteredDirFiles, ...filteredRootFiles]);
	const filesByFolder = /* @__PURE__ */ new Map();
	for (const filePath of allFiles) {
		if (allTrackedFiles.has(filePath)) continue;
		const moduleId = getModuleIdFromPath(filePath);
		if (!installedModuleIds.has(moduleId)) continue;
		const displayFolder = getDisplayFolder(moduleId);
		const file = {
			path: filePath,
			folder: displayFolder,
			moduleId
		};
		const existing = filesByFolder.get(displayFolder) || [];
		existing.push(file);
		filesByFolder.set(displayFolder, existing);
	}
	const result = [];
	const sortedFolders = Array.from(filesByFolder.keys()).sort((a, b) => {
		if (a === "root") return 1;
		if (b === "root") return -1;
		return a.localeCompare(b);
	});
	for (const folder of sortedFolders) {
		const files = filesByFolder.get(folder) || [];
		if (files.length > 0) result.push({
			folder,
			files: files.sort((a, b) => a.path.localeCompare(b.path))
		});
	}
	return result;
}
/**
* 全フォルダの未追跡ファイル数を取得
*/
function getTotalUntrackedCount(untrackedByFolder) {
	return untrackedByFolder.reduce((sum, f) => sum + f.files.length, 0);
}

//#endregion
//#region src/commands/diff.ts
const TEMPLATE_SOURCE$1 = "gh:tktcorporation/.github";
const diffCommand = defineCommand({
	meta: {
		name: "diff",
		description: "Show differences between local and template"
	},
	args: {
		dir: {
			type: "positional",
			description: "Project directory",
			default: "."
		},
		verbose: {
			type: "boolean",
			alias: "v",
			description: "Show detailed diff",
			default: false
		}
	},
	async run({ args: args$1 }) {
		showHeader("berm diff");
		const targetDir = resolve(args$1.dir);
		const configPath = join(targetDir, ".devenv.json");
		if (!existsSync(configPath)) {
			log.error(".devenv.json not found. Run 'init' command first.");
			process.exit(1);
		}
		const configContent = await readFile(configPath, "utf-8");
		const configData = JSON.parse(configContent);
		const parseResult = configSchema.safeParse(configData);
		if (!parseResult.success) {
			log.error("Invalid .devenv.json format");
			log.dim(parseResult.error.message);
			process.exit(1);
		}
		const config = parseResult.data;
		if (config.modules.length === 0) {
			log.warn("No modules installed");
			return;
		}
		const totalSteps = 2;
		step({
			current: 1,
			total: totalSteps
		}, "Fetching template...");
		const tempDir = join(targetDir, ".devenv-temp");
		try {
			const { dir: templateDir } = await withSpinner("Downloading template from GitHub...", () => downloadTemplate(TEMPLATE_SOURCE$1, {
				dir: tempDir,
				force: true
			}));
			let moduleList;
			if (modulesFileExists(templateDir)) moduleList = (await loadModulesFile(templateDir)).modules;
			else moduleList = defaultModules;
			step({
				current: 2,
				total: totalSteps
			}, "Detecting changes...");
			const diff = await withSpinner("Analyzing differences...", () => detectDiff({
				targetDir,
				templateDir,
				moduleIds: config.modules,
				config,
				moduleList
			}));
			const untrackedByFolder = await detectUntrackedFiles({
				targetDir,
				moduleIds: config.modules,
				config,
				moduleList
			});
			const untrackedCount = getTotalUntrackedCount(untrackedByFolder);
			log.newline();
			if (hasDiff(diff)) {
				diffHeader("Changes detected:");
				console.log(formatDiff(diff, args$1.verbose));
				if (untrackedCount > 0) {
					log.newline();
					log.warn(`${untrackedCount} untracked file(s) found outside the sync whitelist:`);
					for (const group of untrackedByFolder) for (const file of group.files) console.log(`  ${pc$1.dim("•")} ${file.path}`);
					log.newline();
					log.info(`To include these files in sync, add them to tracking with the ${pc$1.cyan("track")} command:`);
					log.dim(`  npx @tktco/berm track "<pattern>"`);
					log.dim(`  Example: npx @tktco/berm track "${untrackedByFolder[0]?.files[0]?.path || ".cloud/rules/*.md"}"`);
				}
				log.newline();
				const nextSteps = [{
					command: "npx @tktco/berm push",
					description: "Push your local changes to the template repository"
				}, {
					command: "npx @tktco/berm diff --verbose",
					description: "Show detailed diff output"
				}];
				if (untrackedCount > 0) nextSteps.push({
					command: "npx @tktco/berm track <pattern>",
					description: "Add untracked files to the sync whitelist so they can be pushed"
				});
				showNextSteps(nextSteps);
			} else if (untrackedCount > 0) {
				box("No tracked changes", "success");
				log.info("Your tracked files are in sync with the template.");
				log.newline();
				log.warn(`However, ${untrackedCount} untracked file(s) exist outside the sync whitelist:`);
				for (const group of untrackedByFolder) for (const file of group.files) console.log(`  ${pc$1.dim("•")} ${file.path}`);
				log.newline();
				log.info(`Use ${pc$1.cyan("npx @tktco/berm track <pattern>")} to add them, then ${pc$1.cyan("push")} to sync.`);
				log.newline();
			} else {
				box("No changes", "success");
				log.info("Your local files are in sync with the template");
				log.newline();
			}
		} finally {
			if (existsSync(tempDir)) await rm(tempDir, {
				recursive: true,
				force: true
			});
		}
	}
});

//#endregion
//#region src/prompts/init.ts
async function promptInit(moduleList = defaultModules) {
	const selectedModules = await checkbox({
		message: "適用するテンプレートを選択してください",
		choices: moduleList.map((m) => ({
			name: `${m.name} - ${m.description}`,
			value: m.id,
			checked: true
		}))
	});
	const overwriteStrategy = await select({
		message: "既存ファイルが見つかった場合の処理方法",
		choices: [
			{
				name: "確認しながら進める",
				value: "prompt"
			},
			{
				name: "すべて上書き",
				value: "overwrite"
			},
			{
				name: "スキップ (既存ファイルを保持)",
				value: "skip"
			}
		],
		default: "prompt"
	});
	const result = answersSchema.safeParse({
		modules: selectedModules,
		overwriteStrategy
	});
	if (!result.success) throw new Error(result.error.issues.map((e) => e.message).join("\n"));
	return result.data;
}

//#endregion
//#region src/utils/template.ts
const TEMPLATE_SOURCE = "gh:tktcorporation/.github";
/**
* テンプレートをダウンロードして一時ディレクトリのパスを返す
*/
async function downloadTemplateToTemp(targetDir) {
	const tempDir = join(targetDir, ".devenv-temp");
	const { dir: templateDir } = await downloadTemplate(TEMPLATE_SOURCE, {
		dir: tempDir,
		force: true
	});
	const cleanup = () => {
		if (existsSync(tempDir)) rmSync(tempDir, {
			recursive: true,
			force: true
		});
	};
	return {
		templateDir,
		cleanup
	};
}
/**
* 上書き戦略に従ってファイルを書き込む
*/
async function writeFileWithStrategy(options) {
	const { destPath, content, strategy, relativePath } = options;
	if (!existsSync(destPath)) {
		const destDir = dirname(destPath);
		if (!existsSync(destDir)) mkdirSync(destDir, { recursive: true });
		writeFileSync(destPath, content);
		return {
			action: "created",
			path: relativePath
		};
	}
	return match(strategy).with("overwrite", () => {
		writeFileSync(destPath, content);
		return {
			action: "overwritten",
			path: relativePath
		};
	}).with("skip", () => {
		return {
			action: "skipped",
			path: relativePath
		};
	}).with("prompt", async () => {
		if (await confirm({
			message: `${relativePath} は既に存在します。上書きしますか?`,
			default: false
		})) {
			writeFileSync(destPath, content);
			return {
				action: "overwritten",
				path: relativePath
			};
		}
		return {
			action: "skipped",
			path: relativePath
		};
	}).exhaustive();
}
/**
* テンプレートを取得してパターンベースでコピー
*/
async function fetchTemplates(options) {
	const { targetDir, modules, overwriteStrategy, config, moduleList, templateDir: preDownloadedDir } = options;
	const allResults = [];
	const shouldDownload = !preDownloadedDir;
	const tempDir = join(targetDir, ".devenv-temp");
	let templateDir;
	try {
		if (shouldDownload) templateDir = (await downloadTemplate(TEMPLATE_SOURCE, {
			dir: tempDir,
			force: true
		})).dir;
		else templateDir = preDownloadedDir;
		const gitignore = await loadMergedGitignore([targetDir, templateDir]);
		for (const moduleId of modules) {
			const moduleDef = moduleList ? moduleList.find((m) => m.id === moduleId) : getModuleById(moduleId);
			if (!moduleDef) continue;
			const patterns = getEffectivePatterns(moduleId, moduleDef.patterns, config);
			const { tracked, ignored } = separateByGitignore(resolvePatterns(templateDir, patterns), gitignore);
			if (tracked.length === 0 && ignored.length === 0) {
				log.warn(`No files matched for module "${pc$1.cyan(moduleId)}"`);
				continue;
			}
			for (const relativePath of tracked) {
				const result = await copyFile(join(templateDir, relativePath), join(targetDir, relativePath), overwriteStrategy, relativePath);
				logResult(result);
				allResults.push(result);
			}
			for (const relativePath of ignored) {
				const srcPath = join(templateDir, relativePath);
				const destPath = join(targetDir, relativePath);
				if (existsSync(destPath)) {
					const result = {
						action: "skipped_ignored",
						path: relativePath
					};
					logResult(result);
					allResults.push(result);
				} else {
					const result = await copyFile(srcPath, destPath, overwriteStrategy, relativePath);
					logResult(result);
					allResults.push(result);
				}
			}
		}
	} finally {
		if (shouldDownload && existsSync(tempDir)) rmSync(tempDir, {
			recursive: true,
			force: true
		});
	}
	return allResults;
}
/**
* 単一ファイルをコピー
*/
async function copyFile(srcPath, destPath, strategy, relativePath) {
	if (!existsSync(destPath)) {
		const destDir = dirname(destPath);
		if (!existsSync(destDir)) mkdirSync(destDir, { recursive: true });
		copyFileSync(srcPath, destPath);
		return {
			action: "copied",
			path: relativePath
		};
	}
	switch (strategy) {
		case "overwrite":
			copyFileSync(srcPath, destPath);
			return {
				action: "overwritten",
				path: relativePath
			};
		case "skip": return {
			action: "skipped",
			path: relativePath
		};
		case "prompt":
			if (await confirm({
				message: `${relativePath} は既に存在します。上書きしますか?`,
				default: false
			})) {
				copyFileSync(srcPath, destPath);
				return {
					action: "overwritten",
					path: relativePath
				};
			}
			return {
				action: "skipped",
				path: relativePath
			};
	}
}
function logResult(result) {
	logFileResult(result);
}

//#endregion
//#region src/commands/init.ts
const version = "0.11.2";
const initCommand = defineCommand({
	meta: {
		name: "berm",
		version,
		description: "Apply dev environment template to your project"
	},
	args: {
		dir: {
			type: "positional",
			description: "Target directory",
			default: "."
		},
		force: {
			type: "boolean",
			description: "Overwrite existing files",
			default: false
		},
		yes: {
			type: "boolean",
			alias: "y",
			description: "Select all modules (non-interactive mode)",
			default: false
		},
		modules: {
			type: "string",
			alias: "m",
			description: "Comma-separated module IDs to apply (non-interactive)"
		},
		"overwrite-strategy": {
			type: "string",
			alias: "s",
			description: "Overwrite strategy: overwrite, skip, or prompt (non-interactive)"
		}
	},
	async run({ args: args$1 }) {
		showHeader("berm", version);
		const targetDir = resolve(args$1.dir === "init" ? "." : args$1.dir);
		log.info(`Target: ${pc$1.cyan(targetDir)}`);
		log.newline();
		if (!existsSync(targetDir)) {
			mkdirSync(targetDir, { recursive: true });
			log.dim(`Created directory: ${targetDir}`);
		}
		const totalSteps = 3;
		step({
			current: 1,
			total: totalSteps
		}, "Fetching template...");
		const { templateDir, cleanup } = await withSpinner("Downloading template from GitHub...", () => downloadTemplateToTemp(targetDir));
		try {
			let moduleList;
			if (modulesFileExists(templateDir)) {
				const { modules: loadedModules } = await loadModulesFile(templateDir);
				moduleList = loadedModules;
			} else moduleList = defaultModules;
			step({
				current: 2,
				total: totalSteps
			}, "Selecting modules...");
			log.newline();
			let answers;
			const hasModulesArg = typeof args$1.modules === "string" && args$1.modules.length > 0;
			const hasStrategyArg = typeof args$1["overwrite-strategy"] === "string" && args$1["overwrite-strategy"].length > 0;
			if (args$1.yes || hasModulesArg) {
				let selectedModules;
				if (hasModulesArg) {
					const requestedIds = args$1.modules.split(",").map((s) => s.trim());
					const validIds = moduleList.map((m) => m.id);
					const invalidIds = requestedIds.filter((id) => !validIds.includes(id));
					if (invalidIds.length > 0) {
						log.error(`Unknown module(s): ${invalidIds.join(", ")}. Available: ${validIds.join(", ")}`);
						return;
					}
					selectedModules = requestedIds;
				} else selectedModules = moduleList.map((m) => m.id);
				let overwriteStrategy = "overwrite";
				if (hasStrategyArg) {
					const strategy = args$1["overwrite-strategy"];
					if (strategy !== "overwrite" && strategy !== "skip" && strategy !== "prompt") {
						log.error(`Invalid overwrite strategy: ${strategy}. Must be: overwrite, skip, or prompt`);
						return;
					}
					overwriteStrategy = strategy;
				}
				answers = {
					modules: selectedModules,
					overwriteStrategy
				};
				log.info(`Selected ${pc$1.cyan(selectedModules.length.toString())} modules`);
			} else if (hasStrategyArg) {
				const strategy = args$1["overwrite-strategy"];
				if (strategy !== "overwrite" && strategy !== "skip" && strategy !== "prompt") {
					log.error(`Invalid overwrite strategy: ${strategy}. Must be: overwrite, skip, or prompt`);
					return;
				}
				answers = await promptInit(moduleList);
				answers.overwriteStrategy = strategy;
			} else answers = await promptInit(moduleList);
			if (answers.modules.length === 0) {
				log.warn("No modules selected");
				return;
			}
			log.newline();
			step({
				current: 3,
				total: totalSteps
			}, "Applying templates...");
			log.newline();
			const effectiveStrategy = args$1.force ? "overwrite" : answers.overwriteStrategy;
			const allResults = [...await fetchTemplates({
				targetDir,
				modules: answers.modules,
				overwriteStrategy: effectiveStrategy,
				moduleList,
				templateDir
			})];
			if (answers.modules.includes("devcontainer")) {
				const envResult = await createEnvExample(targetDir, effectiveStrategy);
				allResults.push(envResult);
			}
			const modulesJsoncResult = await copyModulesJsonc(templateDir, targetDir, effectiveStrategy);
			allResults.push(modulesJsoncResult);
			const configResult = await createDevEnvConfig(targetDir, answers.modules);
			allResults.push(configResult);
			for (const result of allResults) logFileResult(result);
			const summary = calculateSummary(allResults);
			showSummary(summary);
			if (summary.added === 0 && summary.updated === 0) {
				log.info("No changes were made");
				return;
			}
			box("Setup complete!", "success");
			displayModuleDescriptions(answers.modules, allResults, moduleList);
			showNextSteps([{
				command: "git add . && git commit -m 'chore: add devenv config'",
				description: "Commit the changes"
			}, {
				command: "npx @tktco/berm diff",
				description: "Check for updates from upstream"
			}]);
		} finally {
			cleanup();
		}
	}
});
const ENV_EXAMPLE_CONTENT = `# 環境変数サンプル
# このファイルを devcontainer.env にコピーして値を設定してください

# GitHub Personal Access Token
GH_TOKEN=

# AWS Credentials (optional)
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=ap-northeast-1

# WakaTime API Key (optional)
WAKATIME_API_KEY=
`;
async function createEnvExample(targetDir, strategy) {
	return writeFileWithStrategy({
		destPath: resolve(targetDir, ".devcontainer/devcontainer.env.example"),
		content: ENV_EXAMPLE_CONTENT,
		strategy,
		relativePath: ".devcontainer/devcontainer.env.example"
	});
}
/**
* 設定ファイル生成（常に更新 - 特別枠）
*/
async function createDevEnvConfig(targetDir, selectedModules) {
	const config = {
		version: "0.1.0",
		installedAt: (/* @__PURE__ */ new Date()).toISOString(),
		modules: selectedModules,
		source: {
			owner: "tktcorporation",
			repo: ".github"
		}
	};
	return writeFileWithStrategy({
		destPath: resolve(targetDir, ".devenv.json"),
		content: JSON.stringify(config, null, 2),
		strategy: "overwrite",
		relativePath: ".devenv.json"
	});
}
/**
* テンプレートから modules.jsonc をコピー
*/
async function copyModulesJsonc(templateDir, targetDir, strategy) {
	const modulesRelPath = ".devenv/modules.jsonc";
	const srcPath = join(templateDir, modulesRelPath);
	const destPath = getModulesFilePath(targetDir);
	if (!existsSync(srcPath)) return {
		action: "skipped",
		path: modulesRelPath
	};
	return copyFile(srcPath, destPath, strategy, modulesRelPath);
}
/**
* モジュール別の説明を表示
*/
function displayModuleDescriptions(selectedModules, fileResults, moduleList) {
	if (!fileResults.some((r) => r.action === "copied" || r.action === "created" || r.action === "overwritten")) return;
	log.info(pc$1.bold("Installed modules:"));
	log.newline();
	for (const moduleId of selectedModules) {
		const mod = getModuleById(moduleId, moduleList);
		if (mod) {
			const description = mod.setupDescription || mod.description;
			console.log(`  ${pc$1.cyan("◆")} ${pc$1.bold(mod.name)}`);
			if (description) console.log(`    ${pc$1.dim(description)}`);
		}
	}
}

//#endregion
//#region src/utils/diff-viewer.ts
/**
* Diff Viewer - モダンな diff 表示コンポーネント
*
* gitui, lazygit などを参考にした見やすい diff 表示を提供
* ts-pattern によるパターンマッチングで堅牢な条件分岐を実現
*
* Features:
* - Word-level diff: 行内の変更箇所をハイライト
* - Syntax highlighting: ファイル拡張子に応じたシンタックスハイライト
*/
const BOX = {
	topLeft: "┌",
	topRight: "┐",
	bottomLeft: "└",
	bottomRight: "┘",
	horizontal: "─",
	vertical: "│",
	tee: "├"
};
const TREE = {
	branch: "├─",
	last: "└─"
};
const DEFAULT_BOX_WIDTH = 60;
const ANSI_REGEX = /\x1b\[[0-9;]*m/g;
/**
* DiffType に対応するスタイルを取得
*/
const getTypeStyle = (type) => match(type).with("added", () => ({
	icon: "✚",
	color: pc.green,
	label: "added"
})).with("modified", () => ({
	icon: "⬡",
	color: pc.yellow,
	label: "modified"
})).with("deleted", () => ({
	icon: "✖",
	color: pc.red,
	label: "deleted"
})).with("unchanged", () => ({
	icon: " ",
	color: pc.dim,
	label: "unchanged"
})).exhaustive();
/**
* Diff 行のタイプを判定
*/
const classifyDiffLine = (line) => match(line).when((l) => l.startsWith("@@"), () => "hunk").when((l) => l.startsWith("+") && !l.startsWith("+++"), () => "addition").when((l) => l.startsWith("-") && !l.startsWith("---"), () => "deletion").otherwise(() => "context");
/**
* Diff 行に色を適用
*/
const colorizeDiffLine = (line, lineType) => match(lineType).with("hunk", () => pc.cyan(line)).with("addition", () => pc.green(line)).with("deletion", () => pc.red(line)).with("context", () => line).exhaustive();
/**
* ファイルの行数を安全に計算
*/
const countLines = (content) => content ? content.split("\n").length : 0;
/**
* unified diff から追加・削除行数を計算
*/
function calculateDiffStats(fileDiff) {
	return match(fileDiff).with({ type: "unchanged" }, () => ({
		additions: 0,
		deletions: 0
	})).with({ type: "deleted" }, (f) => ({
		additions: 0,
		deletions: countLines(f.templateContent)
	})).with({ type: "added" }, (f) => ({
		additions: countLines(f.localContent),
		deletions: 0
	})).with({ type: "modified" }, (f) => {
		const diff = generateUnifiedDiff(f);
		let additions = 0;
		let deletions = 0;
		for (const line of diff.split("\n")) match(classifyDiffLine(line)).with("addition", () => additions++).with("deletion", () => deletions++).otherwise(() => {});
		return {
			additions,
			deletions
		};
	}).exhaustive();
}
/**
* ファイルリストに統計情報を付与
*/
function addStatsToFiles(files) {
	return files.map((file) => ({
		...file,
		stats: calculateDiffStats(file)
	}));
}
/**
* ファイルをタイプ別にグループ化
*/
function groupFilesByType(files) {
	return {
		added: files.filter((f) => f.type === "added"),
		modified: files.filter((f) => f.type === "modified"),
		deleted: files.filter((f) => f.type === "deleted")
	};
}
/**
* 合計統計を計算
*/
function calculateTotalStats(files) {
	return files.reduce((acc, file) => ({
		additions: acc.additions + file.stats.additions,
		deletions: acc.deletions + file.stats.deletions
	}), {
		additions: 0,
		deletions: 0
	});
}
/**
* 統計をフォーマット (+10 -5 形式)
*/
function formatStats(stats) {
	const parts = [];
	match(stats).with({ additions: P.when((n) => n > 0) }, (s) => {
		parts.push(pc.green(`+${s.additions}`));
	}).otherwise(() => {});
	match(stats).with({ deletions: P.when((n) => n > 0) }, (s) => {
		parts.push(pc.red(`-${s.deletions}`));
	}).otherwise(() => {});
	return parts.length === 0 ? pc.dim("(no changes)") : parts.join(" ");
}
/**
* 統計をライン表記でフォーマット (+10 -5 lines)
*/
function formatStatsWithLabel(stats) {
	const parts = [];
	if (stats.additions > 0) parts.push(pc.green(`+${stats.additions}`));
	if (stats.deletions > 0) parts.push(pc.red(`-${stats.deletions}`));
	return parts.length === 0 ? "" : `${parts.join(" ")} lines`;
}
/**
* ボックスの横線を生成
*/
function horizontalLine(width, left, right) {
	return pc.dim(left + BOX.horizontal.repeat(width - 2) + right);
}
/**
* テキストをボックス幅に合わせてパディング
*/
function padLine(text, width) {
	const plainText = text.replace(ANSI_REGEX, "");
	const padding = Math.max(0, width - 4 - plainText.length);
	return `${pc.dim(BOX.vertical)}  ${text}${" ".repeat(padding)}${pc.dim(BOX.vertical)}`;
}
/**
* 単数/複数形を返す
*/
const pluralize = (count, singular, plural) => count === 1 ? singular : plural;
/**
* ファイルグループをレンダリング
*/
function renderFileGroup(files, type, width) {
	if (files.length === 0) return;
	const style = getTypeStyle(type);
	const groupStats = calculateTotalStats(files);
	const fileWord = pluralize(files.length, "file", "files");
	const statsStr = formatStatsWithLabel(groupStats);
	const header = `${style.color(style.icon)} ${style.color(style.label)} (${files.length} ${fileWord})`;
	console.log(padLine(`${header}${statsStr ? "  " + pc.dim(statsStr) : ""}`, width));
	files.forEach((file, i) => {
		const prefix = i === files.length - 1 ? TREE.last : TREE.branch;
		const stats = formatStats(file.stats);
		console.log(padLine(`  ${pc.dim(prefix)} ${file.path}  ${stats}`, width));
	});
	console.log(padLine("", width));
}
/**
* diff サマリーをボックスで表示
*/
function showDiffSummaryBox(files) {
	const filesWithStats = addStatsToFiles(files);
	const grouped = groupFilesByType(filesWithStats);
	const totalStats = calculateTotalStats(filesWithStats);
	const changedFiles = filesWithStats.filter((f) => f.type !== "unchanged");
	const width = DEFAULT_BOX_WIDTH;
	console.log();
	console.log(horizontalLine(width, BOX.topLeft, BOX.topRight));
	console.log(padLine(pc.bold("📦 Changes to push"), width));
	console.log(horizontalLine(width, BOX.tee, BOX.tee));
	console.log(padLine("", width));
	renderFileGroup(grouped.added, "added", width);
	renderFileGroup(grouped.modified, "modified", width);
	renderFileGroup(grouped.deleted, "deleted", width);
	console.log(horizontalLine(width, BOX.tee, BOX.tee));
	const fileWord = pluralize(changedFiles.length, "file", "files");
	const totalLine = `Total: ${changedFiles.length} ${fileWord}  (${formatStatsWithLabel(totalStats)})`;
	console.log(padLine(totalLine, width));
	console.log(horizontalLine(width, BOX.bottomLeft, BOX.bottomRight));
	console.log();
}
/**
* 2つの行の word-level diff を計算
* 変更された単語を背景色でハイライト
*/
function computeWordDiff(oldText, newText) {
	const changes = diffWords(oldText, newText);
	let oldLine = "";
	let newLine = "";
	for (const change of changes) if (change.added) newLine += pc.bgGreen(pc.black(change.value));
	else if (change.removed) oldLine += pc.bgRed(pc.white(change.value));
	else {
		oldLine += change.value;
		newLine += change.value;
	}
	return {
		oldLine,
		newLine
	};
}
function applyWordDiffToLines(lines) {
	const result = [];
	let i = 0;
	while (i < lines.length) {
		const line = lines[i];
		const lineType = classifyDiffLine(line);
		if (lineType === "deletion" && i + 1 < lines.length) {
			const nextLine = lines[i + 1];
			if (classifyDiffLine(nextLine) === "addition") {
				const { oldLine, newLine } = computeWordDiff(line.slice(1), nextLine.slice(1));
				result.push({
					content: `-${oldLine}`,
					lineType: "deletion",
					isWordDiff: true
				});
				result.push({
					content: `+${newLine}`,
					lineType: "addition",
					isWordDiff: true
				});
				i += 2;
				continue;
			}
		}
		result.push({
			content: line,
			lineType,
			isWordDiff: false
		});
		i++;
	}
	return result;
}
/** 拡張子から言語を推測 */
const EXT_TO_LANG = {
	".ts": "typescript",
	".tsx": "typescript",
	".js": "javascript",
	".jsx": "javascript",
	".json": "json",
	".jsonc": "json",
	".md": "markdown",
	".yaml": "yaml",
	".yml": "yaml",
	".css": "css",
	".scss": "scss",
	".html": "html",
	".xml": "xml",
	".sh": "bash",
	".bash": "bash",
	".zsh": "bash",
	".py": "python",
	".rb": "ruby",
	".go": "go",
	".rs": "rust",
	".java": "java",
	".c": "c",
	".cpp": "cpp",
	".h": "c",
	".hpp": "cpp",
	".sql": "sql",
	".graphql": "graphql",
	".gql": "graphql",
	".vue": "vue",
	".svelte": "xml",
	".toml": "toml",
	".ini": "ini",
	".dockerfile": "dockerfile"
};
/**
* ファイルパスから言語を推測
*/
function detectLanguage(filePath) {
	const basename = filePath.split("/").pop() || "";
	if (basename === "Dockerfile") return "dockerfile";
	if (basename === ".gitignore") return "bash";
	if (basename === "Makefile") return "makefile";
	const lang = EXT_TO_LANG[extname(filePath).toLowerCase()];
	if (lang && supportsLanguage(lang)) return lang;
}
/**
* コードにシンタックスハイライトを適用
*/
function applySyntaxHighlight(code, lang) {
	if (!lang) return code;
	try {
		return highlight(code, {
			language: lang,
			ignoreIllegals: true
		});
	} catch {
		return code;
	}
}
/**
* Diff 行をフォーマットしてレンダリング
*/
function renderDiffLine(line, lineType, lineNum, options) {
	const { showLineNumbers, width, lang, isWordDiff } = options;
	const { prefix, nextLineNum } = match(lineType).with("hunk", () => ({
		prefix: "",
		nextLineNum: lineNum
	})).with("addition", () => ({
		prefix: showLineNumbers ? pc.dim(`${String(lineNum + 1).padStart(4)} `) : "",
		nextLineNum: lineNum + 1
	})).with("deletion", () => ({
		prefix: showLineNumbers ? pc.dim("     ") : "",
		nextLineNum: lineNum
	})).with("context", () => ({
		prefix: showLineNumbers ? pc.dim(`${String(lineNum + 1).padStart(4)} `) : "",
		nextLineNum: lineNum + 1
	})).exhaustive();
	let displayLine;
	if (isWordDiff) {
		const linePrefix = line[0];
		const content = line.slice(1);
		displayLine = match(lineType).with("addition", () => pc.green(linePrefix) + content).with("deletion", () => pc.red(linePrefix) + content).otherwise(() => line);
	} else if (lang && lineType !== "hunk") {
		const linePrefix = line[0];
		const highlighted = applySyntaxHighlight(line.slice(1), lang);
		displayLine = match(lineType).with("addition", () => pc.green(linePrefix) + highlighted).with("deletion", () => pc.red(linePrefix) + highlighted).with("context", () => linePrefix + highlighted).otherwise(() => line);
	} else displayLine = colorizeDiffLine(line, lineType);
	const plainLine = line.replace(ANSI_REGEX, "");
	const maxContentWidth = width - 8 - (showLineNumbers ? 5 : 0);
	if (plainLine.length > maxContentWidth) displayLine = colorizeDiffLine(line.slice(0, maxContentWidth - 3) + "...", lineType);
	return {
		output: padLine(`${prefix}${displayLine}`, width),
		newLineNum: nextLineNum
	};
}
/**
* 単一ファイルの diff をボックス表示
*/
function showFileDiffBox(file, index, total, options = {}) {
	const { showLineNumbers = true, maxLines, wordDiff = true, syntaxHighlight = true } = options;
	const stats = calculateDiffStats(file);
	const style = getTypeStyle(file.type);
	const width = DEFAULT_BOX_WIDTH;
	const lang = syntaxHighlight ? detectLanguage(file.path) : void 0;
	console.log();
	console.log(horizontalLine(width, BOX.topLeft, BOX.topRight));
	const position = pc.dim(`[${index + 1}/${total}]`);
	const langBadge = lang ? pc.dim(` [${lang}]`) : "";
	console.log(padLine(`${position} ${style.color(style.icon)} ${pc.bold(file.path)}${langBadge}`, width));
	console.log(padLine(`${style.color(style.label)}  ${formatStatsWithLabel(stats)}`, width));
	console.log(horizontalLine(width, BOX.tee, BOX.tee));
	const lines = generateUnifiedDiff(file).split("\n");
	const isHeaderLine = (line) => line.startsWith("Index:") || line.startsWith("===") || line.startsWith("---") || line.startsWith("+++");
	const contentLines = lines.filter((line) => !isHeaderLine(line));
	const limitedLines = maxLines && contentLines.length > maxLines ? contentLines.slice(0, maxLines) : contentLines;
	const truncated = maxLines && contentLines.length > maxLines;
	const processedLines = wordDiff ? applyWordDiffToLines(limitedLines) : limitedLines.map((line) => ({
		content: line,
		lineType: classifyDiffLine(line),
		isWordDiff: false
	}));
	let lineNum = 0;
	for (const processed of processedLines) {
		const { output, newLineNum } = renderDiffLine(processed.content, processed.lineType, lineNum, {
			showLineNumbers,
			width,
			lang: processed.isWordDiff ? void 0 : lang,
			isWordDiff: processed.isWordDiff
		});
		console.log(output);
		lineNum = newLineNum;
	}
	if (truncated) {
		const remaining = contentLines.length - limitedLines.length;
		console.log(padLine(pc.dim(`... ${remaining} more lines`), width));
	}
	console.log(horizontalLine(width, BOX.tee, BOX.tee));
	console.log(padLine(pc.dim("[Enter] Back  [n] Next  [p] Prev  [q] Quit"), width));
	console.log(horizontalLine(width, BOX.bottomLeft, BOX.bottomRight));
	console.log();
}
/**
* ファイル選択用のラベル生成
*/
function getFileLabel(file) {
	const stats = calculateDiffStats(file);
	const style = getTypeStyle(file.type);
	return `${style.color(style.icon)} ${file.path} (${formatStats(stats)})`;
}

//#endregion
//#region src/prompts/push.ts
/**
* push 実行前の確認プロンプト
*/
async function promptPushConfirm(diff) {
	console.log();
	console.log(formatDiff(diff, false));
	console.log();
	return confirm({
		message: "これらの変更をテンプレートリポジトリに PR として送信しますか？",
		default: false
	});
}
/**
* PR タイトルの入力プロンプト
*/
async function promptPrTitle(defaultTitle) {
	return input({
		message: "PR のタイトルを入力してください",
		default: defaultTitle || "feat: テンプレート設定を更新",
		validate: (value) => {
			if (!value.trim()) return "タイトルは必須です";
			return true;
		}
	});
}
/**
* PR 本文の入力プロンプト（オプション）
*/
async function promptPrBody() {
	if (!await confirm({
		message: "PR の説明を追加しますか？",
		default: false
	})) return;
	return input({ message: "PR の説明を入力してください" });
}
/**
* GitHub トークンの入力プロンプト
*/
async function promptGitHubToken() {
	console.log();
	console.log("GitHub トークンが必要です。");
	console.log("以下のいずれかの方法で設定できます:");
	console.log("  1. 環境変数 GITHUB_TOKEN または GH_TOKEN を設定");
	console.log("  2. 以下のプロンプトで直接入力");
	console.log();
	return password({
		message: "GitHub Personal Access Token を入力してください",
		validate: (value) => {
			if (!value.trim()) return "トークンは必須です";
			if (!value.startsWith("ghp_") && !value.startsWith("gho_") && !value.startsWith("github_pat_")) return "有効な GitHub トークン形式ではありません";
			return true;
		}
	});
}
/** キー入力をアクションに変換 */
const classifyKeyAction = (key) => match(key).with({
	ctrl: true,
	name: "c"
}, () => "forceExit").with({ name: P.union("n", "right", "down", "j") }, () => "next").with({ name: P.union("p", "left", "up", "k") }, () => "prev").with({ name: P.union("return", "q", "escape") }, () => "exit").otherwise(() => "none");
/**
* インタラクティブ diff ビューア
* n/p キーでファイル間をナビゲート、Enter または q で終了
*/
async function interactiveDiffViewer(files) {
	if (files.length === 0) return;
	if (!process.stdin.isTTY) {
		files.forEach((file, i) => {
			showFileDiffBox(file, i, files.length, { showLineNumbers: true });
		});
		return;
	}
	let currentIndex = 0;
	const showCurrentDiff = () => {
		console.clear();
		showFileDiffBox(files[currentIndex], currentIndex, files.length, {
			showLineNumbers: true,
			maxLines: 30
		});
	};
	return new Promise((resolve$1) => {
		try {
			process.stdin.removeAllListeners("keypress");
			let cleanedUp = false;
			const cleanup = () => {
				if (cleanedUp) return;
				cleanedUp = true;
				try {
					process.stdin.removeListener("keypress", handleKeypress);
				} catch {}
				try {
					process.stdin.setRawMode(false);
				} catch {
					console.error("ターミナルの raw モード解除に失敗しました。ターミナルが正常に動作しない場合は `reset` コマンドを実行してください。");
				}
				try {
					process.stdin.resume();
				} catch {
					console.error("標準入力の再開に失敗しました。後続のプロンプトが正常に動作しない可能性があります。");
				}
			};
			const handleKeypress = (_str, key) => {
				match(classifyKeyAction(key)).with("next", () => {
					if (currentIndex < files.length - 1) {
						currentIndex++;
						showCurrentDiff();
					}
				}).with("prev", () => {
					if (currentIndex > 0) {
						currentIndex--;
						showCurrentDiff();
					}
				}).with("exit", () => {
					cleanup();
					console.clear();
					resolve$1();
				}).with("forceExit", () => {
					try {
						cleanup();
					} catch {}
					process.exit(0);
				}).with("none", () => {}).exhaustive();
			};
			readline.emitKeypressEvents(process.stdin);
			process.stdin.setRawMode(true);
			process.stdin.resume();
			process.stdin.on("keypress", handleKeypress);
			showCurrentDiff();
		} catch (error) {
			console.error("インタラクティブ diff ビューアのセットアップに失敗しました。非インタラクティブモードで表示します。", error);
			files.forEach((file, i) => {
				showFileDiffBox(file, i, files.length, { showLineNumbers: true });
			});
			resolve$1();
		}
	});
}
/**
* diff を表示しながらファイルを選択するプロンプト
* Option 2: サマリー → オプションで詳細確認 → ファイル選択
*/
async function promptSelectFilesWithDiff(pushableFiles) {
	if (pushableFiles.length === 0) return [];
	showDiffSummaryBox(pushableFiles);
	if (await confirm({
		message: "詳細な diff を確認しますか？",
		default: false
	})) {
		await interactiveDiffViewer(pushableFiles);
		showDiffSummaryBox(pushableFiles);
	}
	return checkbox({
		message: "PR に含めるファイルを選択してください",
		choices: pushableFiles.map((file) => ({
			name: getFileLabel(file),
			value: file,
			checked: true
		}))
	});
}
/**
* ホワイトリスト外ファイルの追加確認プロンプト
* 2ステップUI: フォルダ選択 → ファイル選択
*/
async function promptAddUntrackedFiles(untrackedByFolder) {
	if (untrackedByFolder.length === 0) return [];
	console.log();
	console.log("=== ホワイトリスト外のファイルが見つかりました ===");
	console.log();
	for (const { folder, files } of untrackedByFolder) console.log(`  ${folder}: ${files.length}件`);
	console.log();
	const selectedFolders = await checkbox({
		message: "詳細を確認するフォルダを選択してください",
		choices: untrackedByFolder.map(({ folder, files }) => ({
			name: `${folder} (${files.length}件)`,
			value: folder,
			checked: true
		}))
	});
	if (selectedFolders.length === 0) return [];
	const selectedFolderData = untrackedByFolder.filter((f) => selectedFolders.includes(f.folder));
	const allFileChoices = [];
	for (const { folder, files } of selectedFolderData) {
		allFileChoices.push(new Separator(`\n  ── ${folder} ──`));
		const sortedFiles = [...files].sort((a, b) => a.path.localeCompare(b.path));
		for (let i = 0; i < sortedFiles.length; i++) {
			const file = sortedFiles[i];
			const prefix = i === sortedFiles.length - 1 ? "└─" : "├─";
			const relativePath = file.path.startsWith(`${folder}/`) ? file.path.slice(folder.length + 1) : file.path;
			allFileChoices.push({
				name: `${prefix} ${relativePath}`,
				value: file
			});
		}
	}
	const selectedFiles = await checkbox({
		message: "push 対象に追加するファイルを選択してください",
		choices: allFileChoices
	});
	if (selectedFiles.length === 0) return [];
	const byModuleId = /* @__PURE__ */ new Map();
	for (const file of selectedFiles) {
		const existing = byModuleId.get(file.moduleId) || [];
		existing.push(file.path);
		byModuleId.set(file.moduleId, existing);
	}
	const result = [];
	for (const [moduleId, files] of byModuleId) result.push({
		moduleId,
		files
	});
	return result;
}

//#endregion
//#region src/utils/github.ts
/**
* GitHub API を使って PR を作成
*/
async function createPullRequest(token, options) {
	const octokit = new Octokit({ auth: token });
	const { owner, repo, files, title, body, baseBranch = "main" } = options;
	const { data: user } = await octokit.users.getAuthenticated();
	const forkOwner = user.login;
	let forkRepo;
	try {
		const { data: fork } = await octokit.repos.get({
			owner: forkOwner,
			repo
		});
		forkRepo = fork.name;
	} catch {
		const { data: fork } = await octokit.repos.createFork({
			owner,
			repo
		});
		forkRepo = fork.name;
		await sleep(3e3);
	}
	const { data: baseBranchRef } = await octokit.repos.getBranch({
		owner,
		repo,
		branch: baseBranch
	});
	const baseSha = baseBranchRef.commit.sha;
	const branchName = `devenv-sync-${Date.now()}`;
	await octokit.git.createRef({
		owner: forkOwner,
		repo: forkRepo,
		ref: `refs/heads/${branchName}`,
		sha: baseSha
	});
	for (const file of files) {
		let existingSha;
		try {
			const { data: existingFile } = await octokit.repos.getContent({
				owner: forkOwner,
				repo: forkRepo,
				path: file.path,
				ref: branchName
			});
			if (!Array.isArray(existingFile) && existingFile.type === "file") existingSha = existingFile.sha;
		} catch {}
		await octokit.repos.createOrUpdateFileContents({
			owner: forkOwner,
			repo: forkRepo,
			path: file.path,
			message: `Update ${file.path}`,
			content: Buffer.from(file.content).toString("base64"),
			branch: branchName,
			sha: existingSha
		});
	}
	const { data: pr } = await octokit.pulls.create({
		owner,
		repo,
		title,
		body: body || generatePrBody(files),
		head: `${forkOwner}:${branchName}`,
		base: baseBranch
	});
	return {
		url: pr.html_url,
		number: pr.number,
		branch: branchName
	};
}
/**
* PR の本文を生成
*/
function generatePrBody(files) {
	return `## Summary

Auto-generated PR by berm push command.

## Changed files

${files.map((f) => `- \`${f.path}\``).join("\n")}

---
Generated by [@tktco/berm](https://github.com/tktcorporation/.github/tree/main/packages/berm)
`;
}
/**
* GitHub トークンを環境変数から取得
*/
function getGitHubToken() {
	return process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
}
/**
* sleep utility
*/
function sleep(ms) {
	return new Promise((resolve$1) => setTimeout(resolve$1, ms));
}

//#endregion
//#region src/utils/readme.ts
/**
* README.md の自動生成ユーティリティ
*/
const MARKERS = {
	features: {
		start: "<!-- FEATURES:START -->",
		end: "<!-- FEATURES:END -->"
	},
	commands: {
		start: "<!-- COMMANDS:START -->",
		end: "<!-- COMMANDS:END -->"
	},
	files: {
		start: "<!-- FILES:START -->",
		end: "<!-- FILES:END -->"
	}
};
/**
* modules.jsonc を読み込み
*/
async function loadModulesFromFile(modulesPath) {
	if (!existsSync(modulesPath)) return [];
	return parse$1(await readFile(modulesPath, "utf-8")).modules;
}
/**
* 機能セクションを生成
*/
function generateFeaturesSection(modules) {
	const lines = [];
	lines.push("## 機能\n");
	for (const mod of modules) lines.push(`- **${mod.name}** - ${mod.description}`);
	lines.push("");
	return lines.join("\n");
}
/**
* 生成されるファイルセクションを生成
*/
function generateFilesSection(modules) {
	const lines = [];
	lines.push("## 生成されるファイル\n");
	lines.push("選択したモジュールに応じて以下のファイルが生成されます：\n");
	for (const mod of modules) {
		const dirName = mod.id === "." ? "ルート" : `\`${mod.id}/\``;
		lines.push(`### ${dirName}\n`);
		lines.push(`${mod.description}\n`);
		for (const pattern of mod.patterns) {
			const displayPattern = pattern.includes("*") ? `\`${pattern}\` (パターン)` : `\`${pattern}\``;
			lines.push(`- ${displayPattern}`);
		}
		lines.push("");
	}
	lines.push("### 設定ファイル\n");
	lines.push("- `.devenv.json` - このツールの設定（適用したモジュール情報）\n");
	return lines.join("\n");
}
/**
* README のマーカー間を更新
*/
function updateSection(content, startMarker, endMarker, newSection) {
	const startIndex = content.indexOf(startMarker);
	const endIndex = content.indexOf(endMarker);
	if (startIndex === -1 || endIndex === -1) return {
		content,
		updated: false
	};
	const newContent = `${content.slice(0, startIndex + startMarker.length)}\n\n${newSection}\n${content.slice(endIndex)}`;
	return {
		content: newContent,
		updated: newContent !== content
	};
}
/**
* README を生成
*/
async function generateReadme(options) {
	const { readmePath, modulesPath, generateCommandsSection } = options;
	if (!existsSync(readmePath)) return {
		updated: false,
		content: "",
		readmePath
	};
	const modules = await loadModulesFromFile(modulesPath);
	let readme = await readFile(readmePath, "utf-8");
	let anyUpdated = false;
	if (modules.length > 0) {
		const featuresSection = generateFeaturesSection(modules);
		const result = updateSection(readme, MARKERS.features.start, MARKERS.features.end, featuresSection);
		readme = result.content;
		anyUpdated = anyUpdated || result.updated;
	}
	if (generateCommandsSection) {
		const commandsSection = await generateCommandsSection();
		const result = updateSection(readme, MARKERS.commands.start, MARKERS.commands.end, commandsSection);
		readme = result.content;
		anyUpdated = anyUpdated || result.updated;
	}
	if (modules.length > 0) {
		const filesSection = generateFilesSection(modules);
		const result = updateSection(readme, MARKERS.files.start, MARKERS.files.end, filesSection);
		readme = result.content;
		anyUpdated = anyUpdated || result.updated;
	}
	return {
		updated: anyUpdated,
		content: readme,
		readmePath
	};
}
/**
* README を更新して保存
*/
async function updateReadmeFile(options) {
	const result = await generateReadme(options);
	if (result.updated) await writeFile(result.readmePath, result.content);
	return result;
}
/**
* プロジェクトディレクトリ内の README を検出して更新
* @param targetDir プロジェクトのルートディレクトリ
* @param templateDir テンプレートディレクトリ（modules.jsonc の場所）
*/
async function detectAndUpdateReadme(targetDir, templateDir) {
	const readmePath = join(targetDir, "README.md");
	const modulesPath = join(templateDir, ".devenv/modules.jsonc");
	if (!existsSync(readmePath)) return null;
	const readmeContent = await readFile(readmePath, "utf-8");
	if (!(readmeContent.includes(MARKERS.features.start) || readmeContent.includes(MARKERS.files.start))) return null;
	return updateReadmeFile({
		readmePath,
		modulesPath
	});
}

//#endregion
//#region src/commands/push.ts
const MODULES_FILE_PATH = ".devenv/modules.jsonc";
const README_PATH = "README.md";
/**
* ローカルの modules.jsonc とテンプレートの modules.jsonc を比較し、
* ローカルにのみ存在するモジュール（track コマンドで追加されたもの等）を検出してマージする。
* テンプレートの raw content をベースに新モジュールを追加した内容を返す。
*/
async function detectLocalModuleAdditions(targetDir, templateModules, templateRawContent) {
	if (!modulesFileExists(targetDir)) return {
		mergedModuleList: templateModules,
		newModuleIds: [],
		updatedModulesContent: void 0
	};
	const local = await loadModulesFile(targetDir);
	const templateModuleIds = new Set(templateModules.map((m) => m.id));
	const newModules = local.modules.filter((m) => !templateModuleIds.has(m.id));
	if (newModules.length === 0) {
		let updatedContent$1 = templateRawContent;
		let hasPatternAdditions = false;
		for (const localMod of local.modules) {
			const templateMod = templateModules.find((m) => m.id === localMod.id);
			if (!templateMod) continue;
			const newPatterns = localMod.patterns.filter((p) => !templateMod.patterns.includes(p));
			if (newPatterns.length > 0) {
				updatedContent$1 = addPatternToModulesFileWithCreate(updatedContent$1, localMod.id, newPatterns);
				hasPatternAdditions = true;
			}
		}
		if (hasPatternAdditions) return {
			mergedModuleList: parse$1(updatedContent$1).modules,
			newModuleIds: [],
			updatedModulesContent: updatedContent$1
		};
		return {
			mergedModuleList: templateModules,
			newModuleIds: [],
			updatedModulesContent: void 0
		};
	}
	let updatedContent = templateRawContent;
	for (const mod of newModules) updatedContent = addPatternToModulesFileWithCreate(updatedContent, mod.id, mod.patterns, {
		name: mod.name,
		description: mod.description
	});
	for (const localMod of local.modules) {
		const templateMod = templateModules.find((m) => m.id === localMod.id);
		if (!templateMod) continue;
		const newPatterns = localMod.patterns.filter((p) => !templateMod.patterns.includes(p));
		if (newPatterns.length > 0) updatedContent = addPatternToModulesFileWithCreate(updatedContent, localMod.id, newPatterns);
	}
	return {
		mergedModuleList: parse$1(updatedContent).modules,
		newModuleIds: newModules.map((m) => m.id),
		updatedModulesContent: updatedContent
	};
}
/**
* --execute モード: マニフェストファイルを使ってPRを作成
*/
async function runExecuteMode(targetDir, config, messageOverride) {
	const totalSteps = 4;
	let currentStep = 1;
	step({
		current: currentStep++,
		total: totalSteps
	}, "Loading manifest...");
	let manifest;
	try {
		manifest = await loadManifest(targetDir);
	} catch (error) {
		log.error(error.message);
		process.exit(1);
	}
	const selectedFilePaths = getSelectedFilePaths(manifest);
	const selectedUntracked = getSelectedUntrackedFiles(manifest);
	if (selectedFilePaths.length === 0 && selectedUntracked.size === 0) {
		log.newline();
		log.info("No files selected in manifest. Nothing to push.");
		log.dim(`Edit ${MANIFEST_FILENAME} and set 'selected: true' for files you want to include.`);
		return;
	}
	log.success(`${selectedFilePaths.length} files selected from manifest`);
	if (selectedUntracked.size > 0) {
		const untrackedCount = Array.from(selectedUntracked.values()).reduce((sum, files) => sum + files.length, 0);
		log.success(`${untrackedCount} untracked files will be added to patterns`);
	}
	step({
		current: currentStep++,
		total: totalSteps
	}, "Fetching template...");
	const tempDir = join(targetDir, ".devenv-temp");
	try {
		const { dir: templateDir } = await withSpinner("Downloading template from GitHub...", () => downloadTemplate(TEMPLATE_SOURCE, {
			dir: tempDir,
			force: true
		}));
		let moduleList;
		let modulesRawContent;
		if (modulesFileExists(templateDir)) {
			const loaded = await loadModulesFile(templateDir);
			moduleList = loaded.modules;
			modulesRawContent = loaded.rawContent;
		} else moduleList = defaultModules;
		const effectiveModuleIds = [...config.modules];
		let updatedModulesContent;
		if (modulesRawContent) {
			const localAdditions = await detectLocalModuleAdditions(targetDir, moduleList, modulesRawContent);
			moduleList = localAdditions.mergedModuleList;
			updatedModulesContent = localAdditions.updatedModulesContent;
			for (const id of localAdditions.newModuleIds) if (!effectiveModuleIds.includes(id)) effectiveModuleIds.push(id);
		}
		if (selectedUntracked.size > 0 && modulesRawContent) {
			let currentContent = updatedModulesContent || modulesRawContent;
			for (const [moduleId, filePaths] of selectedUntracked) currentContent = addPatternToModulesFileWithCreate(currentContent, moduleId, filePaths);
			updatedModulesContent = currentContent;
			moduleList = parse$1(updatedModulesContent).modules;
		}
		step({
			current: currentStep++,
			total: totalSteps
		}, "Preparing files...");
		const diff = await withSpinner("Analyzing differences...", () => detectDiff({
			targetDir,
			templateDir,
			moduleIds: effectiveModuleIds,
			config,
			moduleList
		}));
		const currentPushableFiles = getPushableFiles(diff);
		const currentFilePaths = new Set(currentPushableFiles.map((f) => f.path));
		const manifestFilePaths = new Set(manifest.files.map((f) => f.path));
		const missingFiles = selectedFilePaths.filter((p) => !currentFilePaths.has(p));
		const newFiles = currentPushableFiles.filter((f) => !manifestFilePaths.has(f.path)).map((f) => f.path);
		if (missingFiles.length > 0 || newFiles.length > 0) {
			log.newline();
			log.warn("Manifest is out of sync with current changes:");
			if (missingFiles.length > 0) log.dim(`  Missing files (in manifest but no longer changed): ${missingFiles.join(", ")}`);
			if (newFiles.length > 0) log.dim(`  New files (changed but not in manifest): ${newFiles.join(", ")}`);
			log.dim("  Consider running 'berm push --prepare' to regenerate the manifest.");
			log.newline();
		}
		const pushableFiles = getPushableFiles(diff);
		const allSelectedPaths = [...selectedFilePaths, ...Array.from(selectedUntracked.values()).flat()];
		const files = pushableFiles.filter((f) => allSelectedPaths.includes(f.path)).map((f) => ({
			path: f.path,
			content: f.localContent || ""
		}));
		if (updatedModulesContent) {
			if (selectedFilePaths.includes(MODULES_FILE_PATH) || selectedUntracked.size > 0) {
				const existingIdx = files.findIndex((f) => f.path === MODULES_FILE_PATH);
				if (existingIdx !== -1) files[existingIdx].content = updatedModulesContent;
				else files.push({
					path: MODULES_FILE_PATH,
					content: updatedModulesContent
				});
			}
		}
		const readmeResult = await detectAndUpdateReadme(targetDir, templateDir);
		if (readmeResult?.updated) files.push({
			path: README_PATH,
			content: readmeResult.content
		});
		if (files.length === 0) {
			log.newline();
			log.info("No files to push after processing.");
			return;
		}
		let token = manifest.github.token || getGitHubToken();
		if (!token) {
			log.newline();
			log.error("GitHub token not found.");
			log.dim("Set GITHUB_TOKEN/GH_TOKEN environment variable, or add token to manifest.");
			process.exit(1);
		}
		const title = messageOverride || manifest.pr.title;
		const body = manifest.pr.body;
		step({
			current: currentStep++,
			total: totalSteps
		}, "Creating pull request...");
		const result = await withSpinner("Creating PR on GitHub...", () => createPullRequest(token, {
			owner: config.source.owner,
			repo: config.source.repo,
			files,
			title,
			body,
			baseBranch: config.source.ref || "main"
		}));
		await deleteManifest(targetDir);
		box("Pull request created!", "success");
		console.log(`  ${pc$1.bold("URL:")}    ${pc$1.cyan(result.url)}`);
		console.log(`  ${pc$1.bold("Branch:")} ${result.branch}`);
		console.log(`  ${pc$1.bold("Files:")}  ${files.length} files included`);
		log.newline();
		log.dim(`Cleaned up ${MANIFEST_FILENAME}`);
		log.newline();
		showNextSteps([{ description: `Review and merge the PR at ${result.url}` }]);
	} finally {
		if (existsSync(tempDir)) await rm(tempDir, {
			recursive: true,
			force: true
		});
	}
}
const pushCommand = defineCommand({
	meta: {
		name: "push",
		description: "Push local changes to the template repository as a PR"
	},
	args: {
		dir: {
			type: "positional",
			description: "Project directory",
			default: "."
		},
		dryRun: {
			type: "boolean",
			alias: "n",
			description: "Preview only, don't create PR",
			default: false
		},
		message: {
			type: "string",
			alias: "m",
			description: "PR title"
		},
		force: {
			type: "boolean",
			alias: "f",
			description: "Skip confirmation prompts",
			default: false
		},
		interactive: {
			type: "boolean",
			alias: "i",
			description: "Select files while reviewing diffs (enabled by default)",
			default: true
		},
		prepare: {
			type: "boolean",
			alias: "p",
			description: "Generate a manifest file for AI-agent friendly workflow (no PR created)",
			default: false
		},
		execute: {
			type: "boolean",
			alias: "e",
			description: "Execute push using the manifest file generated by --prepare",
			default: false
		}
	},
	async run({ args: args$1 }) {
		showHeader("berm push");
		if (args$1.prepare && args$1.execute) {
			log.error("Cannot use --prepare and --execute together.");
			log.dim("Use --prepare to generate a manifest, then --execute to create the PR.");
			process.exit(1);
		}
		if (args$1.prepare && args$1.dryRun) log.warn("--dry-run is ignored with --prepare (--prepare doesn't create a PR).");
		if (args$1.execute && args$1.interactive) log.dim("Note: --execute mode is non-interactive. File selection is based on the manifest.");
		const targetDir = resolve(args$1.dir);
		const configPath = join(targetDir, ".devenv.json");
		if (!existsSync(configPath)) {
			log.error(".devenv.json not found. Run 'init' command first.");
			process.exit(1);
		}
		const configContent = await readFile(configPath, "utf-8");
		const configData = JSON.parse(configContent);
		const parseResult = configSchema.safeParse(configData);
		if (!parseResult.success) {
			log.error("Invalid .devenv.json format");
			log.dim(parseResult.error.message);
			process.exit(1);
		}
		const config = parseResult.data;
		if (config.modules.length === 0) {
			log.warn("No modules installed");
			return;
		}
		if (args$1.execute) {
			await runExecuteMode(targetDir, config, args$1.message);
			return;
		}
		const totalSteps = args$1.dryRun ? 2 : args$1.prepare ? 2 : 4;
		let currentStep = 1;
		step({
			current: currentStep++,
			total: totalSteps
		}, "Fetching template...");
		const tempDir = join(targetDir, ".devenv-temp");
		try {
			const { dir: templateDir } = await withSpinner("Downloading template from GitHub...", () => downloadTemplate(TEMPLATE_SOURCE, {
				dir: tempDir,
				force: true
			}));
			let moduleList;
			let modulesRawContent;
			if (modulesFileExists(templateDir)) {
				const loaded = await loadModulesFile(templateDir);
				moduleList = loaded.modules;
				modulesRawContent = loaded.rawContent;
			} else moduleList = defaultModules;
			const effectiveModuleIds = [...config.modules];
			let updatedModulesContent;
			if (modulesRawContent) {
				const localAdditions = await detectLocalModuleAdditions(targetDir, moduleList, modulesRawContent);
				moduleList = localAdditions.mergedModuleList;
				updatedModulesContent = localAdditions.updatedModulesContent;
				for (const id of localAdditions.newModuleIds) if (!effectiveModuleIds.includes(id)) effectiveModuleIds.push(id);
				if (localAdditions.newModuleIds.length > 0) {
					log.newline();
					log.info(`Detected ${localAdditions.newModuleIds.length} new module(s) from local: ${localAdditions.newModuleIds.join(", ")}`);
				}
			}
			if (!args$1.force && !args$1.prepare && modulesRawContent) {
				const untrackedByFolder = await detectUntrackedFiles({
					targetDir,
					moduleIds: effectiveModuleIds,
					config,
					moduleList
				});
				if (untrackedByFolder.length > 0) {
					log.newline();
					log.info(pc$1.bold("Untracked files detected:"));
					log.newline();
					const selectedFiles = await promptAddUntrackedFiles(untrackedByFolder);
					if (selectedFiles.length > 0) {
						let currentContent = updatedModulesContent || modulesRawContent;
						for (const { moduleId, files: files$1 } of selectedFiles) currentContent = addPatternToModulesFileWithCreate(currentContent, moduleId, files$1);
						updatedModulesContent = currentContent;
						moduleList = parse$1(updatedModulesContent).modules;
						const totalAdded = selectedFiles.reduce((sum, s) => sum + s.files.length, 0);
						log.success(`${totalAdded} patterns will be added to modules.jsonc`);
					}
				}
			}
			step({
				current: currentStep++,
				total: totalSteps
			}, "Detecting changes...");
			const diff = await withSpinner("Analyzing differences...", () => detectDiff({
				targetDir,
				templateDir,
				moduleIds: effectiveModuleIds,
				config,
				moduleList
			}));
			let pushableFiles = getPushableFiles(diff);
			if (pushableFiles.length === 0 && !updatedModulesContent) {
				log.newline();
				log.info("No changes to push");
				diffHeader("Current status:");
				console.log(formatDiff(diff, false));
				return;
			}
			if (args$1.dryRun) {
				log.newline();
				box("Dry run mode", "info");
				diffHeader("Files that would be included in PR:");
				console.log(formatDiff(diff, true));
				if (updatedModulesContent) console.log(`  ${pc$1.green("+")} ${MODULES_FILE_PATH} ${pc$1.dim("(pattern additions)")}`);
				log.newline();
				log.info("No PR was created (dry run)");
				return;
			}
			if (args$1.prepare) {
				const untrackedByFolder = !args$1.force && modulesRawContent ? await detectUntrackedFiles({
					targetDir,
					moduleIds: effectiveModuleIds,
					config,
					moduleList
				}) : [];
				const manifestPath = await saveManifest(targetDir, generateManifest({
					targetDir,
					diff,
					pushableFiles,
					untrackedByFolder,
					defaultTitle: args$1.message,
					modulesFileChange: updatedModulesContent ? MODULES_FILE_PATH : void 0
				}));
				log.newline();
				box("Manifest file generated!", "success");
				log.newline();
				console.log(`  ${pc$1.bold("File:")} ${pc$1.cyan(manifestPath)}`);
				console.log(`  ${pc$1.bold("Files:")} ${pushableFiles.length} files ready to push`);
				if (updatedModulesContent) console.log(`  ${pc$1.bold("Modules:")} modules.jsonc will be updated (new modules/patterns detected)`);
				if (untrackedByFolder.length > 0) {
					const untrackedCount = untrackedByFolder.reduce((sum, f) => sum + f.files.length, 0);
					console.log(`  ${pc$1.bold("Untracked:")} ${untrackedCount} files detected (not selected by default)`);
					log.newline();
					log.info(`${pc$1.bold("Hint:")} To sync untracked files to the template, first add them to tracking:`);
					log.dim(`  npx @tktco/berm track "<pattern>"  # Add file patterns to the sync whitelist`);
					log.dim(`  npx @tktco/berm track --list        # List currently tracked patterns`);
					log.dim(`  Then re-run 'push --prepare' to include them in the manifest.`);
				}
				log.newline();
				showNextSteps([
					{ description: `Edit ${MANIFEST_FILENAME} to select files and configure PR` },
					{ description: `Run 'berm push --execute' to create the PR` },
					...untrackedByFolder.length > 0 ? [{ description: `Run 'berm track <pattern>' to add untracked files to sync whitelist` }] : []
				]);
				return;
			}
			step({
				current: currentStep++,
				total: totalSteps
			}, "Selecting files...");
			log.newline();
			if (args$1.interactive && !args$1.force) {
				pushableFiles = await promptSelectFilesWithDiff(pushableFiles);
				if (pushableFiles.length === 0 && !updatedModulesContent) {
					log.info("No files selected. Cancelled.");
					return;
				}
			} else if (!args$1.force) {
				if (!await promptPushConfirm(diff)) {
					log.info("Cancelled");
					return;
				}
			}
			let token = getGitHubToken();
			if (!token) {
				log.newline();
				token = await promptGitHubToken();
			}
			log.newline();
			const title = args$1.message || await promptPrTitle();
			const body = await promptPrBody();
			const readmeResult = await detectAndUpdateReadme(targetDir, templateDir);
			const files = pushableFiles.map((f) => ({
				path: f.path,
				content: f.localContent || ""
			}));
			if (updatedModulesContent) files.push({
				path: MODULES_FILE_PATH,
				content: updatedModulesContent
			});
			if (readmeResult?.updated) files.push({
				path: README_PATH,
				content: readmeResult.content
			});
			step({
				current: currentStep++,
				total: totalSteps
			}, "Creating pull request...");
			const result = await withSpinner("Creating PR on GitHub...", () => createPullRequest(token, {
				owner: config.source.owner,
				repo: config.source.repo,
				files,
				title,
				body,
				baseBranch: config.source.ref || "main"
			}));
			box("Pull request created!", "success");
			console.log(`  ${pc$1.bold("URL:")}    ${pc$1.cyan(result.url)}`);
			console.log(`  ${pc$1.bold("Branch:")} ${result.branch}`);
			log.newline();
			showNextSteps([{ description: `Review and merge the PR at ${result.url}` }]);
		} finally {
			if (existsSync(tempDir)) await rm(tempDir, {
				recursive: true,
				force: true
			});
		}
	}
});

//#endregion
//#region src/commands/track.ts
/**
* パターン文字列からモジュール ID を推定
* 例: ".cloud/rules/*.md" → ".cloud"
*     ".mcp.json" → "."
*     ".github/workflows/ci.yml" → ".github"
*/
function inferModuleId(pattern) {
	return getModuleIdFromPath(pattern.replace(/\*.*$/, "").replace(/\{.*$/, "") || pattern);
}
const trackCommand = defineCommand({
	meta: {
		name: "track",
		description: "Add file patterns to the tracking whitelist in modules.jsonc"
	},
	args: {
		patterns: {
			type: "positional",
			description: "File paths or glob patterns to track (e.g., .cloud/rules/*.md)",
			required: true
		},
		dir: {
			type: "string",
			alias: "d",
			description: "Project directory (default: current directory)",
			default: "."
		},
		module: {
			type: "string",
			alias: "m",
			description: "Module ID to add patterns to (auto-detected from path if omitted)"
		},
		name: {
			type: "string",
			description: "Module name (used when creating a new module)"
		},
		description: {
			type: "string",
			description: "Module description (used when creating a new module)"
		},
		list: {
			type: "boolean",
			alias: "l",
			description: "List all currently tracked modules and patterns",
			default: false
		}
	},
	async run({ args: args$1 }) {
		showHeader("berm track");
		const targetDir = resolve(args$1.dir);
		if (!modulesFileExists(targetDir)) {
			log.error(".devenv/modules.jsonc not found.");
			log.dim("Run 'berm init' first to set up the project.");
			process.exit(1);
		}
		if (args$1.list) {
			const { modules } = await loadModulesFile(targetDir);
			log.newline();
			log.info(pc$1.bold("Tracked modules and patterns:"));
			log.newline();
			for (const mod of modules) {
				console.log(`  ${pc$1.cyan(mod.id)} ${pc$1.dim(`(${mod.name})`)}`);
				if (mod.description) console.log(`    ${pc$1.dim(mod.description)}`);
				for (const pattern of mod.patterns) console.log(`    ${pc$1.dim("→")} ${pattern}`);
				log.newline();
			}
			return;
		}
		const rawArgs = process.argv.slice(2);
		const trackIdx = rawArgs.indexOf("track");
		const argsAfterTrack = trackIdx !== -1 ? rawArgs.slice(trackIdx + 1) : rawArgs;
		const patterns = [];
		let i = 0;
		while (i < argsAfterTrack.length) {
			const arg = argsAfterTrack[i];
			if (arg === "--list" || arg === "-l" || arg === "--help" || arg === "-h") {
				i++;
				continue;
			}
			if (arg === "--dir" || arg === "-d" || arg === "--module" || arg === "-m" || arg === "--name" || arg === "--description") {
				i += 2;
				continue;
			}
			if (!arg.startsWith("-")) patterns.push(arg);
			i++;
		}
		if (patterns.length === 0) {
			log.error("No patterns specified.");
			log.dim("Usage: berm track <patterns...> [--module <id>]");
			log.dim("Example: berm track '.cloud/rules/*.md' '.cloud/config.json'");
			process.exit(1);
		}
		const moduleId = args$1.module || inferModuleId(patterns[0]);
		const { rawContent } = await loadModulesFile(targetDir);
		const updatedContent = addPatternToModulesFileWithCreate(rawContent, moduleId, patterns, {
			name: args$1.name,
			description: args$1.description
		});
		if (updatedContent === rawContent) {
			log.newline();
			log.info("All patterns are already tracked. No changes needed.");
			return;
		}
		await saveModulesFile(targetDir, updatedContent);
		log.newline();
		box("Patterns added!", "success");
		log.newline();
		console.log(`  ${pc$1.bold("Module:")} ${pc$1.cyan(moduleId)}`);
		console.log(`  ${pc$1.bold("Added:")}`);
		for (const pattern of patterns) console.log(`    ${pc$1.green("+")} ${pattern}`);
		log.newline();
		log.dim(`Updated .devenv/modules.jsonc`);
		log.newline();
	}
});

//#endregion
//#region src/index.ts
const main = defineCommand({
	meta: {
		name: "berm",
		version: version$1,
		description: "Dev environment template manager"
	},
	subCommands: {
		init: initCommand,
		push: pushCommand,
		diff: diffCommand,
		track: trackCommand,
		"ai-docs": aiDocsCommand
	}
});
const commandMap = {
	init: initCommand,
	push: pushCommand,
	diff: diffCommand
};
/**
* AI エージェント向けのヒントを表示
*/
function showAiHint() {
	log.newline();
	console.log(pc$1.dim("─".repeat(40)));
	console.log(`${pc$1.dim("🤖 Are you an AI agent?")} Run ${pc$1.cyan("npx @tktco/berm ai-docs")} for non-interactive usage guide.`);
	console.log(pc$1.dim("─".repeat(40)));
	log.newline();
}
/**
* コマンド選択プロンプト
*/
async function promptCommand() {
	showHeader("berm", version$1);
	showAiHint();
	log.info("Select a command to run:");
	log.newline();
	const selectedCommand = commandMap[await select({
		message: "Command",
		choices: [
			{
				name: `${pc$1.cyan("init")}   ${pc$1.dim("→")} Apply template to your project`,
				value: "init"
			},
			{
				name: `${pc$1.cyan("push")}   ${pc$1.dim("→")} Push local changes as a PR`,
				value: "push"
			},
			{
				name: `${pc$1.cyan("diff")}   ${pc$1.dim("→")} Show differences from template`,
				value: "diff"
			}
		]
	})];
	runMain(selectedCommand);
}
const args = process.argv.slice(2);
const hasSubCommand = args.length > 0 && [
	"init",
	"push",
	"diff",
	"track",
	"ai-docs",
	"--help",
	"-h",
	"--version",
	"-v"
].includes(args[0]);
if (!hasSubCommand && args.length > 0 && !args[0].startsWith("-")) runMain(initCommand);
else if (!hasSubCommand && args.length === 0) promptCommand();
else runMain(main);

//#endregion
export {  };